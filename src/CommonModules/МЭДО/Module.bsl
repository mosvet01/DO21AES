#Если НЕ ВнешнееСоединение Тогда

#Область ПрограммныйИнтерфейс

// Определяет список входящих документов, полученных через МЭДО, которые требуется обработать.
// 
// Параметры:
//  МассивДокументов - Массив из ОпределяемыйТип.ПредметМЭДО,Неопределено - Массив документов
// 
// Возвращаемое значение:
//  ТаблицаЗначений -- таблица с колонками::
// * ИдентификаторСообщения - Строка - УИд сообщения обмена.
//   в удобочитаемой форме.
// * Состояние - ПеречислениеСсылка.СостоянияДокументовМЭДО - состояние
//   входящего документа.
// * Документ - ОпределяемыйТип.ПредметМЭДО - ссылка на входящий документ.
Функция ВходящиеДокументыКОбработке(МассивДокументов = Неопределено) Экспорт
	
	Возврат РегистрыСведений.СостоянияДокументовМЭДО.ПолучитьСрезСостоянияДокументов(
		Перечисления.НаправленияСообщенийМЭДО.Входящее,
		"ИдентификаторСообщения, Состояние, Документ",
		,
		Перечисления.СостоянияДокументовМЭДО.СостоянияВходящиеДокументыКОбработке(),
		МассивДокументов);
	
КонецФункции

// Определяет список уведомлений, полученных через МЭДО, которые требуется обработать.
//
// Параметры:
//  МассивДокументов - Массив из ОпределяемыйТип.ПредметМЭДО,Неопределено - Массив документов
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица с колонками:
//     * Документ - ОпределяемыйТип.ПредметМЭДО - ссылка на исходящий документ к отправке.
//     * Уведомление - Строка - содержание уведомления.
//     * Состояние - ПеречислениеСсылка.СостоянияДокументовМЭДО - состояние
//               исходящего документа.
//
Функция ВходящиеУведомленияКОбработке(МассивДокументов = Неопределено) Экспорт
	
	Возврат РегистрыСведений.СостоянияДокументовМЭДО.ПолучитьСрезСостоянияДокументов(
		Перечисления.НаправленияСообщенийМЭДО.Исходящее,
		"ПредметСообщения, ПредметСообщения.ТипУведомления КАК ТипУведомления, Документ, ИдентификаторСообщения, Состояние",
		,
		Перечисления.СостоянияДокументовМЭДО.СостоянияВходящиеУведомленияКОбработке(),
		МассивДокументов);
	
КонецФункции

// Массово создает уведомления об отказе в регистрации. 
// Исключение. В этой ситуации, при отказе от регистрации уведомление можно создать сразу, 
// предварительно не открывая форму пользователю:
//
// Параметры:
//   МассивДокументов - Массив из ОпределяемыйТип.ПредметМЭДО - массив
//   ПричинаОтказа - СправочникСсылка.ПричиныОтказаВРегистрацииМЭДО
Процедура СоздатьОтказыВРегистрации(МассивДокументов, ПричинаОтказа) Экспорт
	
	Если Не ЗначениеЗаполнено(ПричинаОтказа) Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			НСтр("ru = 'Не задана ""Причина отказа"", операция отменена.'"),
			,
			,
			МЭДОСтруктурыДанных.НовыйЛегкийОтвет());
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Для Каждого Документ Из МассивДокументов Цикл
		Реквизиты = ИнтеграцияСМЭДО.ПолучитьТребуемыеДанныеВходящегоДокумента(
			Документ, "Организация, Контрагент, ДатаУчетаДокумента", МЭДОСтруктурыДанных.НовыйЛегкийОтвет());
		
		СтруктураСостояния = РегистрыСведений.СостоянияДокументовМЭДО.ПолучитьСостояниеДокумента(
			Документ, Перечисления.СостоянияДокументовМЭДО.ДокументПолучен, 
			"ИдентификаторДокумента, ИдентификаторСообщения", Реквизиты.ДатаУчетаДокумента);
		
		Уведомление = Документы.УведомлениеМЭДО.СоздатьДокумент();
		Уведомление.Дата = ТекущаяДатаСеанса();
		Уведомление.ИсходящаяДата = ТекущаяДатаСеанса();
		Уведомление.Направление = Перечисления.НаправленияСообщенийМЭДО.Исходящее;
		Уведомление.Заполнить(Неопределено);
		Уведомление.Организация = Реквизиты.Организация;
		Уведомление.Контрагент = Реквизиты.Контрагент;
		Уведомление.ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОбОтказеВРегистрации;
		Уведомление.Документ = Документ;
		Уведомление.ИдентификаторДокумента = СтруктураСостояния.ИдентификаторДокумента;
		Уведомление.ИдентификаторУведомления = СтруктураСостояния.ИдентификаторСообщения;
		Уведомление.Отправлено = Ложь;
		Уведомление.ГотовоКОтправке = Истина;
		НоваяСтрока = Уведомление.ОтказВРегистрации.Добавить();
		НоваяСтрока.ПричинаОтказа = ПричинаОтказа;
		Попытка
			Уведомление.Записать();
		Исключение
			ТекстОшибкиКратко = НСтр("ru = 'Ошибка создания уведомления об отказе в регистрации'");
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				Документ,
				ТекстОшибкиКратко,
				ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()),
				МЭДОСтруктурыДанных.НовыйЛегкийОтвет());
			ВызватьИсключение;
		КонецПопытки;
	КонецЦикла;
	
КонецПроцедуры

// Изменить признак отправки документа.
// 
// Параметры:
//  Документ - ОпределяемыйТип.ПредметМЭДО
//  НазваниеДействия - Строка - "ОтменитьОтправку" или "ПовторитьОтправку"
Процедура ИзменитьПризнакОтправки(Документ, НазваниеДействия) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ДанныеОтвета = МЭДОСтруктурыДанных.НовыйЛегкийОтвет();
	ДанныеМэдо = Документы.ДанныеДокументаМЭДО.ПолучитьДанныеДокументаМЭДО(Документ, "Ссылка, ГотовКОтправке, Отправлен", ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ДанныеМэдо.Ссылка) Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			Документ,
			НСтр("ru = 'Ошибка записи ""Данных документа МЭДО""'"),
			СтрШаблон(НСтр("ru = 'К документу %1 не найдено ""Данных документа МЭДО""'"), Документ),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Если НазваниеДействия = "ОтменитьОтправку" И ДанныеМэдо.ГотовКОтправке Тогда
		ДанныеМэдоОбъект = ДанныеМэдо.Ссылка.ПолучитьОбъект();
		ДанныеМэдоОбъект.ГотовКОтправке = Ложь;
		ДанныеМэдоОбъект.Записать();
	ИначеЕсли НазваниеДействия = "ПовторитьОтправку" И ДанныеМэдо.Отправлен = Истина Тогда 
		ДанныеМэдоОбъект = ДанныеМэдо.Ссылка.ПолучитьОбъект();
		ДанныеМэдоОбъект.Отправлен = Ложь;
		ДанныеМэдоОбъект.ГотовКОтправве = Истина;
		ДанныеМэдоОбъект.Записать();
	КонецЕсли;
	
КонецПроцедуры

// Функция-обертка, для упрощения возврата значений с длинными названиями
// 
// Параметры:
//  Значение - Произвольный - Значение
//  ЗначениеЕслиПусто - Произвольный - Значение если пусто
// 
// Возвращаемое значение:
//  Произвольный - Заполненное значение
Функция ЗаполненноеЗначение(Значение, ЗначениеЕслиПусто = Неопределено) Экспорт
	
	Возврат ?(ЗначениеЗаполнено(Значение), Значение, ЗначениеЕслиПусто);
	
КонецФункции

// Функция-обертка - в зависимости от заполненности выводит значение в строку, с префиксом и постфиксом.
// 
// Параметры:
//  Префикс - Строка - Префикс
//  Значение - Произвольный - Значение
//  Постфикс - Строка - Постфикс
//  ЗначениеЕслиПусто - Строка - Значение если пусто
// 
// Возвращаемое значение:
//  Строка 
Функция ЗаполненноеЗначениеСтрокой(Префикс, Значение, Постфикс, ЗначениеЕслиПусто = "") Экспорт
	
	Если ЗначениеЗаполнено(Значение) Тогда
		Возврат "" + Префикс + Значение + Постфикс;
	КонецЕсли;
	Возврат ЗначениеЕслиПусто;
	
КонецФункции

// Присвоить, если значение заполнено.
// 
// Параметры:
//  ЧтоПрисвоить - Произвольный - Что присвоить.
//  ЧемуРавно - Произвольный - Чему присвоить.
//
// Возвращаемое значение:
//  Булево - Истина, если удалось присвоить, Ложь, если на вход пришло пустое значение.
Функция ПрисвоитьЗаполненное(ЧтоПрисвоить, ЧемуРавно) Экспорт
	
	Если ЗначениеЗаполнено(ЧемуРавно) И ЧтоПрисвоить <> ЧемуРавно Тогда
		ЧтоПрисвоить = ЧемуРавно;
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Присвоить, если значение отличается, чтобы не возникала модифицированность, если не нужно.
// 
// Параметры:
//  ЧтоПрисвоить - Произвольный - Что присвоить.
//  ЧемуРавно - Произвольный - Чему присвоить.
//
// Возвращаемое значение:
//  Булево - Истина, если удалось присвоить, Ложь, если на вход пришло пустое значение.
Функция ПрисвоитьОтличающееся(ЧтоПрисвоить, ЧемуРавно) Экспорт
	
	Если ЧтоПрисвоить <> ЧемуРавно Тогда
		ЧтоПрисвоить = ЧемуРавно;
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

#Область Обмен_ТочкиВхода

// Обработчик регламентного задания, выполняет обмен МЭДО по расписанию.
Процедура ВыполнитьОбменМЭДО() Экспорт
	
	Отказ = Ложь;
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.ВыполнениеОбменаМЭДО, Отказ);
	
	Если Отказ = Истина Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Все организации, которые настроены:
	Запрос = Новый Запрос(
		"ВЫБРАТЬ
		|	Настройки.Организация,
		|	Настройки.КаталогПолучения,
		|	Настройки.КаталогОтправки,
		|	Настройки.РазмерПорции
		|ИЗ
		|	РегистрСведений.НастройкиОрганизацийМЭДО КАК Настройки");
	Результат = Запрос.Выполнить();
	Настройки = МЭДОСтруктурыДанных.НовыйСтруктураИзКолонокОбъекта(Результат);
	Выборка = Результат.Выбрать();
	ДанныеОтвета = МЭДОСтруктурыДанных.НовыйЛегкийОтвет();
	Пока Выборка.Следующий() Цикл
		
		ЗаполнитьЗначенияСвойств(Настройки, Выборка);
		РегистрыСведений.НастройкиОрганизацийМЭДО.ПроверкаКритичноВажныхПолей(
			Выборка.Организация, Настройки, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Продолжить;
		КонецЕсли;
		
		ПолучитьВходящиеСообщения(Настройки);
		ОтправитьИсходящиеКвитанции(Настройки);
		ДанныеОтвета = МЭДОСтруктурыДанных.НовыйЛегкийОтвет();
		ОтправитьИсходящиеДокументы(Настройки, ДанныеОтвета, Неопределено);
		ОтправитьИсходящиеУведомления(Настройки, ДанныеОтвета, Неопределено);
		
	КонецЦикла;
	
КонецПроцедуры

// Прочитать сообщения из каталога получения
// 
// Параметры:
//  Настройки - Структура - поля:
//   * Организация - ОпределяемыйТип.Организация
//   * КаталогПолучения - Строка
//   * РазмерПорции - Число
//  ТипыКонтента - Строка - Через запятую типы контента, по умолчанию все возможные типы. Если перечислить не все типы,
//							то входные файл не того типа во входном каталоге будут пропущены.
Процедура ПолучитьВходящиеСообщения(
	Настройки, ТипыКонтента = "Транспортный контейнер, Документ, Уведомление, Квитанция") Экспорт
	
	Путь = Настройки.КаталогПолучения;
	ПутьСРазделителем = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(Путь);
	
	ДанныеОтвета = МЭДОСтруктурыДанных.НовыйЛегкийОтвет();
	
	ПроверитьСуществуетЛиКаталог(Путь, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	
	ПутьПринятых = ПутьСРазделителем + ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути("processed");
	СоздатьКаталогЕслиНет(ПутьПринятых, ДанныеОтвета);
	ПутьОшибочных = ПутьСРазделителем + ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути("errors");
	СоздатьКаталогЕслиНет(ПутьОшибочных, ДанныеОтвета);
	
	// Входные сообщения могут приходить, как в папках, так и zip-архивах, где внутри те же файлы, приводим все 
	// к архивам, т.к. в случае ошибки в журнал кладется архив с сообщением:
	Счетчик = 0;
	Для Каждого Папка Из НайтиФайлы(Путь, "*.*") Цикл
		Если Не Папка.ЭтоКаталог() Тогда
			Продолжить;
		КонецЕсли;
		Если Папка.ПолноеИмя = Путь Тогда
			Продолжить; // находит саму себя тоже.
		КонецЕсли;
		Если Папка.Имя = "processed" Или Папка.Имя = "errors" Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяАрхива = ПутьСРазделителем + Папка.Имя + ".zip";
		ЗаписьАрхива = Новый ЗаписьZipФайла(ИмяАрхива, , , , УровеньСжатияZIP.Оптимальный);
		ЗаписьАрхива.Добавить(
			ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(Папка.ПолноеИмя) + "*.*",
			РежимСохраненияПутейZIP.СохранятьОтносительныеПути,
			РежимОбработкиПодкаталоговZIP.ОбрабатыватьРекурсивно);
		ЗаписьАрхива.Записать();
		УдалитьФайлы(Папка.ПолноеИмя);
		
		Счетчик = Счетчик + 1;
		Если Счетчик > Настройки.РазмерПорции Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;

	Счетчик = 0;
	Для Каждого ФайлЭСД Из НайтиФайлы(Путь, "*.zip") Цикл
		// Передаем исходный zip-архив, в случае ошибок будет сохраняться в журнале.
		ДанныеОтвета = МЭДОСтруктурыДанных.НовыйОтвет(ФайлЭСД.Имя, Новый ДвоичныеДанные(ФайлЭСД.ПолноеИмя));
		
		ОбработатьВходящееЭСД(
			ФайлЭСД, Настройки.Организация, ТипыКонтента, ДанныеОтвета);
		
		Если ДанныеОтвета.СообщениеОбОшибке = "ДругойВерныйТипСообщения" Тогда
			Продолжить;
		ИначеЕсли ДанныеОтвета.Успех Тогда
			ПереместитьФайл(ФайлЭСД.ПолноеИмя, ПутьПринятых + ФайлЭСД.Имя);
		Иначе
			ПереместитьФайл(ФайлЭСД.ПолноеИмя, ПутьОшибочных + ФайлЭСД.Имя);
		Конецесли;
		
		Счетчик = Счетчик + 1;
		Если Счетчик > Настройки.РазмерПорции Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Записать сообщения по исходящим документам в каталог отправки
// 
// Параметры:
//  Настройки - Структура - поля:
//   * Организация - ОпределяемыйТип.Организация
//   * КаталогОтправки - Строка
//   * РазмерПорции - Число
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
//  МассивДокументов - Массив из ОпределяемыйТип.ПредметМЭДО, Неопределено - Если Неопределено, то все, подлежащие 
//  																		отправке по этой организации, 
//																			либо отбор по выбранным документам.
Процедура ОтправитьИсходящиеДокументы(Настройки, ДанныеОтвета, МассивДокументов = Неопределено) Экспорт
	
	ПроверитьСуществуетЛиКаталог(Настройки.КаталогОтправки, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаДокументов = ИсходящиеДокументыКОтправке(Настройки, МассивДокументов);
	Для Каждого СтрокаТЗ Из ТаблицаДокументов Цикл
		ДанныеОтвета = МЭДОСтруктурыДанных.НовыйЛегкийОтвет();
		ОтправитьИсходящийДокумент(Настройки, СтрокаТЗ.Документ, ДанныеОтвета);
	КонецЦикла;
	
КонецПроцедуры

// Записать сообщение по исходящему документу в каталог отправки
// 
// Параметры:
//  Настройки - Структура - поля:
//   * Организация - ОпределяемыйТип.Организация
//   * КаталогОтправки - Строка
//  ИсходящийДокумент - ОпределяемыйТип.ПредметМЭДО
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
//
// Возвращаемое значение:
//   Булево - Успешно или нет.
Функция ОтправитьИсходящийДокумент(Настройки, ИсходящийДокумент, ДанныеОтвета) Экспорт
	
	ДанныеДокумента = ИнтеграцияСМЭДО.ДанныеИсходящегоДокументаДляОтправки(ИсходящийДокумент, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ЗаписатьСодержимоеКонтейнераИсходящегоДокумента(ДанныеДокумента, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ЗаписатьСообщениеПоИсходящемуДокументу(Настройки.КаталогОтправки, ДанныеДокумента, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Если ЗначениеЗаполнено(ДанныеДокумента.ПодкаталогСообщения) Тогда
			УдалитьФайлы(ДанныеДокумента.ПодкаталогСообщения);
		КонецЕсли;
		Если ЗначениеЗаполнено(ДанныеДокумента.ВременныйКаталог) Тогда
			УдалитьФайлы(ДанныеДокумента.ВременныйКаталог);
		КонецЕсли;
		
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Записать сообщения по квитанциям в папку откправки.
// 
// Параметры:
//  Настройки - Структура - поля:
//   * Организация - ОпределяемыйТип.Организация
//   * КаталогОтправки - Строка
//   * РазмерПорции - Число
Процедура ОтправитьИсходящиеКвитанции(Настройки) Экспорт
	
	ДанныеОтвета = МЭДОСтруктурыДанных.НовыйЛегкийОтвет();
	ПроверитьСуществуетЛиКаталог(Настройки.КаталогОтправки, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	
	ДанныеКвитанций = ДанныеИсходящихКвитанцийДляОтправки(Настройки);
	
	Счетчик = 0;
	Для Каждого КлючИЗначение Из ДанныеКвитанций Цикл
		Квитанция = КлючИЗначение.Ключ;
		ДанныеКвитанции = КлючИЗначение.Значение;
		
		Счетчик = Счетчик + 1;
		Если Счетчик > Настройки.РазмерПорции Тогда
			Прервать;
		КонецЕсли;
		
		ДанныеОтвета = МЭДОСтруктурыДанных.НовыйОтвет();
		ЗаписатьСообщениеПоИсходящейКвитанции(Настройки.КаталогОтправки, Квитанция, ДанныеКвитанции, ДанныеОтвета);
		
		Если Не ДанныеОтвета.Успех Тогда
			Если ЗначениеЗаполнено(ДанныеКвитанции.ПодкаталогСообщения) Тогда
				УдалитьФайлы(ДанныеКвитанции.ПодкаталогСообщения);
			КонецЕсли;
			Если ЗначениеЗаполнено(ДанныеКвитанции.ВременныйКаталог) Тогда
				УдалитьФайлы(ДанныеКвитанции.ВременныйКаталог);
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Записать сообщения по исходящим уведомлениям в каталог отправки
// 
// Параметры:
//  Настройки - Структура - поля:
//   * Организация - ОпределяемыйТип.Организация
//   * КаталогОтправки - Строка
//   * РазмерПорции - Число
//  ДанныеОтвета - Структура - Данные ответа:
//   * Организация - ОпределяемыйТип.Организация
//   * КаталогОтправки - Строка
//   * РазмерПорции - Число
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
//  МассивУведомлений - Массив из ДокументСсылка.УведомлениеМЭДО - Если Неопределено, то все, подлежащие 
//  																отправке по этой организации, 
//																	либо отбор по выбранным уведомлениям.
Процедура ОтправитьИсходящиеУведомления(Настройки, ДанныеОтвета, МассивУведомлений = Неопределено) Экспорт

	ПроверитьСуществуетЛиКаталог(Настройки.КаталогОтправки, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаУведомлений = ИсходящиеУведомленияКОтправке(Настройки, МассивУведомлений);
	
	Для Каждого СтрокаТЗ Из ТаблицаУведомлений Цикл
		ДанныеОтвета = МЭДОСтруктурыДанных.НовыйОтвет();
		ОтправитьИсходящееУведомление(Настройки, СтрокаТЗ.ПредметСообщения, ДанныеОтвета);
	КонецЦикла;
	
КонецПроцедуры

// Записать сообщение по исходящему уведомлению в каталог отправки
// 
// Параметры:
//  Настройки - Структура - поля:
//   * Организация - ОпределяемыйТип.Организация
//   * КаталогОтправки - Строка
//  УведомлениеСсылка - ОпределяемыйТип.ПредметМЭДО
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
//
// Возвращаемое значение:
//   Булево - Успешно или нет.
Функция ОтправитьИсходящееУведомление(Настройки, УведомлениеСсылка, ДанныеОтвета) Экспорт

	Если Не ЗначениеЗаполнено(УведомлениеСсылка) Тогда
		Возврат Ложь;
	КонецЕсли;

	ДанныеУведомления = ДанныеИсходящегоУведомленияДляОтправки(УведомлениеСсылка, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ДанныеОтвета = МЭДОСтруктурыДанных.НовыйЛегкийОтвет();
	ЗаписатьСообщениеПоИсходящемуУведомлению(
		Настройки, ДанныеУведомления, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Если ЗначениеЗаполнено(ДанныеУведомления.ПодкаталогСообщения) Тогда
			УдалитьФайлы(ДанныеУведомления.ПодкаталогСообщения);
		КонецЕсли;
		Если ЗначениеЗаполнено(ДанныеУведомления.ВременныйКаталог) Тогда
			УдалитьФайлы(ДанныеУведомления.ВременныйКаталог);
		КонецЕсли;
		
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;

КонецФункции

#КонецОбласти

#Область ИсходящиеДокументы

// Определяет список исходящих документов, которые требуется отправить через МЭДО.
//
// Параметры:
//  Настройки - Структура - поля:
//   * Организация - ОпределяемыйТип.Организация
//   * КаталогОтправки - Строка
//   * РазмерПорции - Число
//  МассивДокументов - Массив из ОпределяемыйТип.ПредметМЭДО, Неопределено - Если задано, то отбор по документам, если
//  																		не задано, то все, готовые к отправке.
// 
// Возвращаемое значение:
//   ТаблицаЗначений - таблица с колонками:
//     * Документ - ОпределяемыйТип.ПредметМЭДО - ссылка на исходящий документ к отправке.
//     * ИдентификаторСообщения - Строка
//     * Состояние - ПеречислениеСсылка.СостоянияДокументовМЭДО - состояние
//               исходящего документа.
Функция ИсходящиеДокументыКОтправке(Настройки, МассивДокументов = Неопределено) Экспорт
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 9999
		|	ДанныеМЭДО.Документ,
		|	ДанныеМЭДО.ИдентификаторСообщения,
		|	Состояния.Состояние
		|ИЗ
		|	Документ.ДанныеДокументаМЭДО КАК ДанныеМЭДО
		|	ЛЕВОЕ СОЕДИНЕНИЕ
		|	РегистрСведений.СостоянияДокументовМЭДО.СрезПоследних(
		|		, Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Исходящее)
		|		) КАК Состояния
		|		ПО ДанныеМЭДО.Документ = Состояния.Документ
		|ГДЕ
		|	ДанныеМЭДО.ГотовКОтправке
		|	И НЕ ДанныеМЭДО.ПометкаУдаления
		|	И НЕ ДанныеМЭДО.Документ.ПометкаУдаления
		|	И ДанныеМЭДО.Организация = &Организация
		|	И ДанныеМЭДО.Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Исходящее)
		|	И &ОтборДокументов
		|
		|УПОРЯДОЧИТЬ ПО
		|	ДанныеМЭДО.Дата");
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "9999", "" + Настройки.РазмерПорции);
	Запрос.УстановитьПараметр("Организация", Настройки.Организация);
	Если МассивДокументов <> Неопределено Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ОтборДокументов", "ДанныеМЭДО.Документ В (&МассивДокументов)");
		Запрос.УстановитьПараметр("МассивДокументов", МассивДокументов);
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ОтборДокументов", "ИСТИНА");
	КонецЕсли;
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

// Процедура - Записывает во временные файлы содержимое контейнера исходящего документа.
// 
// Параметры:
//  Данные			- см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоДокументаДляОтправки.
//  ДанныеОтвета	- см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ЗаписатьСодержимоеКонтейнераИсходящегоДокумента(Данные, ДанныеОтвета) Экспорт
	
	Попытка
		ВременныйКаталог = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ПолучитьИмяВременногоФайла());
		// (Каталог будет удален уже на последнем этапе, в конце см. ЗаписатьСообщениеПоИсходящемуДокументу.

		СоздатьКаталог(ВременныйКаталог);
		Данные.ВременныйКаталог = ВременныйКаталог;
		ОбъединяемыеФайлы = Новый СписокЗначений();
		
		// Паспорт контейнера (passport.xml).
		ФайлПаспортаКонтейнера = ВременныйКаталог + "passport.xml";
		СоздатьПаспортКонтейнераИсходящегоДокумента(Данные, ФайлПаспортаКонтейнера, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат;
		КонецЕсли;
		ОбъединяемыеФайлы.Добавить(ФайлПаспортаКонтейнера, "");
		
		// Файл документа (pdf).
		ФайлДокумента = ВременныйКаталог + Данные.Файл.ЛокальноеИмя;
		Данные.Файл.ДвоичныеДанные.Записать(ФайлДокумента);
		ОбъединяемыеФайлы.Добавить(ФайлДокумента, Данные.Файл.ЛокальноеИмя);
		
		// Регистрационный штамп (png).
		ПолноеИмяФайлаРегШтампа = ВременныйКаталог + Данные.Отправитель.РегистрационныйШтамп.Файл.ЛокальноеИмя;
		Данные.Отправитель.РегистрационныйШтамп.Файл.ДвоичныеДанные.Записать(ПолноеИмяФайлаРегШтампа);
		ОбъединяемыеФайлы.Добавить(ПолноеИмяФайлаРегШтампа, Данные.Отправитель.РегистрационныйШтамп.Файл.ЛокальноеИмя);
		
		Для Каждого Подпись Из Данные.Отправитель.Подписи Цикл
			// Сама подпись (p7s).
			ПолноеИмяФайлаПодписи = ВременныйКаталог + Подпись.Файл.ЛокальноеИмя;
			Подпись.Файл.ДвоичныеДанные.Записать(ПолноеИмяФайлаПодписи);
			ОбъединяемыеФайлы.Добавить(ПолноеИмяФайлаПодписи, Подпись.Файл.ЛокальноеИмя);
			
			// Отметка подписи (png).
			ФайлОтметкиПодписи = ВременныйКаталог + Подпись.ОтметкаЭП.Файл.ЛокальноеИмя;
			Подпись.ОтметкаЭП.Файл.ДвоичныеДанные.Записать(ФайлОтметкиПодписи);
			ОбъединяемыеФайлы.Добавить(ФайлОтметкиПодписи, Подпись.ОтметкаЭП.Файл.ЛокальноеИмя);
		КонецЦикла;
		
		// Приложения, если они есть.
		Для Каждого Приложение Из Данные.Приложения Цикл
			Если ТипЗнч(Приложение.ДвоичныеДанные) = Тип("ДвоичныеДанные") Тогда
				ПолноеИмяФайлаПриложения = ВременныйКаталог + Приложение.ЛокальноеИмя;
				Приложение.ДвоичныеДанные.Записать(ПолноеИмяФайлаПриложения);
				ОбъединяемыеФайлы.Добавить(ПолноеИмяФайлаПриложения, Приложение.ЛокальноеИмя);
			КонецЕсли
		КонецЦикла;
		
		
		ОбъединяемыеФайлы.СортироватьПоПредставлению();
		ОбъединяемыеФайлыМассив = ОбъединяемыеФайлы.ВыгрузитьЗначения();
		Данные.СодержимоеКонтейнера.ЛокальноеИмя = "container.bin";
		ИмяРезультирующегоФайла = ВременныйКаталог + Данные.СодержимоеКонтейнера.ЛокальноеИмя;
		ОбъединитьФайлы(ОбъединяемыеФайлыМассив, ИмяРезультирующегоФайла);
		Данные.СодержимоеКонтейнера.ДвоичныеДанные = Новый ДвоичныеДанные(ИмяРезультирующегоФайла);
	Исключение
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			Данные.Документ,
			НСтр("ru='Ошибка записи данных контейнера исходящего документа'"),
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()),
			ДанныеОтвета);
	КонецПопытки;
	
КонецПроцедуры

// Создает и записывает сообщение по исходящему документу.
// 
// Параметры:
//  Путь - Строка - путь к каталогу для помещения сообщения.
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоДокументаДляОтправки.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ЗаписатьСообщениеПоИсходящемуДокументу(Путь, Данные, ДанныеОтвета) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ВерсияМЭДО = Данные.ВерсияМЭДО;
	ИдентификаторСообщения = Данные.ИдентификаторСообщения;
	
	НачатьТранзакцию();
	Попытка
		
		ЕстьКонтейнер = (ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия27
			Или ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271);
		
		ПодкаталогСообщения = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(
			ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(Путь) + ИдентификаторСообщения);
		СоздатьКаталог(ПодкаталогСообщения);
		Данные.ПодкаталогСообщения = ПодкаталогСообщения;
		
		// В 2.5 нет контейнера, в новых версиях есть:
		ФайлыСтрокой = "";
		Если ЕстьКонтейнер Тогда
			ПолноеИмяФайлаКонтейнера = ПодкаталогСообщения + "document.edc.zip";
			ДвоичныеДанные = ПолучитьДвоичныеДанныеКонтейнераИсходящегоДокумента(Данные);
			ДвоичныеДанные.Записать(ПолноеИмяФайлаКонтейнера);
			ФайлыСтрокой = 
				"0=document.edc.zip
				|1=document.xml";
		Иначе
			ФайлыСтрокой = СтрШаблон(
				"0=document.xml
				|1=%1", Данные.Файл.ЛокальноеИмя);
			НомерФайла = 1;
			ПереместитьФайл(Данные.ВременныйКаталог + Данные.Файл.ЛокальноеИмя, ПодкаталогСообщения + Данные.Файл.ЛокальноеИмя);
			Для Каждого Приложение Из Данные.Приложения Цикл
				НомерФайла = НомерФайла + 1;
				ФайлыСтрокой = ФайлыСтрокой + Символы.ПС + СтрШаблон("%1=%2", Формат(НомерФайла, "ЧН=0; ЧГ=0"), Приложение.ЛокальноеИмя);
				ПереместитьФайл(Данные.ВременныйКаталог + Приложение.ЛокальноеИмя, ПодкаталогСообщения + Приложение.ЛокальноеИмя);
			КонецЦикла;
		КонецЕсли;
		
		Адресаты = Новый Массив();
		НомерАдресата = 0;
		Для Каждого Получатель Из Данные.Получатели Цикл
			Если ЗначениеЗаполнено(Получатель.Контрагент.АдресМЭДО) Тогда
				Адресат = СтрШаблон("%1=%2", Формат(НомерАдресата, "ЧН=0; ЧГ=0"), Получатель.Контрагент.АдресМЭДО);
				Адресаты.Добавить(Адресат);
				НомерАдресата = НомерАдресата + 1;
			КонецЕсли;
		КонецЦикла;
		Если Адресаты.Количество() = 0 Тогда
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				Данные.Документ,
				Текст_ОшибкаВКонтрагенте(),
				НСтр("ru = 'Ни у одного из получателей исходящего документа не указан адрес МЭДО.'"),
				ДанныеОтвета);
			Возврат;
		КонецЕсли;
		АдресатыСтрокой = СтрСоединить(Адресаты, Символы.ПС);
		
		Данные.Заголовок = СтрЗаменить(Данные.Заголовок, """", "");
		Данные.Заголовок = СтрЗаменить(Данные.Заголовок, "'", "");
		
		ПолноеИмяФайлаКонверта = ПодкаталогСообщения + "envelope.ini";
		Конверт = Новый ТекстовыйДокумент;
		Конверт.УстановитьТекст(СтрШаблон(
			"[ПИСЬМО КП ПС СЗИ]
			|ТЕМА=%1
			|АВТООТПРАВКА=1
			|[АДРЕСАТЫ]
			|%2
			|[ФАЙЛЫ]
			|%3",
			Данные.Заголовок, АдресатыСтрокой, ФайлыСтрокой));
		Конверт.Записать(ПолноеИмяФайлаКонверта, "windows-1251");
		
		ПолноеИмяФайлаСообщения = ПодкаталогСообщения + "document.xml";
		Пакет = ПакетXDTOСообщенияПоВерсииМЭДО(ВерсияМЭДО);
		ТипCommunication = Пакет.КорневыеСвойства.Получить("communication").Тип;
		communication = ФабрикаXDTO.Создать(ТипCommunication);
		
		communication.version = "" + ВерсияМЭДО;
		
		communication.header = ФабрикаXDTO.Создать(ТипCommunication.Свойства.Получить("header").Тип);
		communication.header.type = ?(ЕстьКонтейнер, "Транспортный контейнер", "Документ");
		communication.header.uid = НРег(ИдентификаторСообщения);
		communication.header.source = НовыйОбъектСообщения("communicationPartner", ВерсияМЭДО);
		communication.header.source.uid = НРег(Данные.Отправитель.Организация.Идентификатор);
		communication.header.source.organization = Данные.Отправитель.Организация.Наименование;
		
		Если ЕстьКонтейнер Тогда
			communication.container = НовыйОбъектСообщения("documentContainer", ВерсияМЭДО);
			communication.container.body = "document.edc.zip";
		КонецЕсли;
		
		Если ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
			communication.header.created = ДатаФорматаDateTimeZone(Данные.ДатаУчетаДокумента);
		Иначе
			communication.header.created = Данные.ДатаУчетаДокумента;
			
			// В 2.5 все данные документа берутся из пакета сообщения. В 2.7 так тоже возможно, но есть и второй 
			// пакет контейнер, внутри.
			document = НовыйОбъектСообщения("document", ВерсияМЭДО); // Есть только в схеме 2.7.
			document.uid = НРег(Данные.ИдентификаторДокумента);
			
			Данные.Заголовок = СтрЗаменить(Данные.Заголовок, """", "");
			Данные.Заголовок = СтрЗаменить(Данные.Заголовок, "'", "");
			document.annotation = Данные.Заголовок;
			document.pages = Данные.КоличествоЛистов;
			
			num = НовыйОбъектСообщения("documentNumber", ВерсияМЭДО);
			num.number = Данные.Отправитель.РегистрационныйНомер;
			num.date = Данные.Отправитель.ДатаРегистрации;
			document.num = num;
			
			ПрисвоитьЗаполненное(document.comment, Данные.Содержание);
			
			signatory = НовыйОбъектСообщения("signatory", ВерсияМЭДО);
			// в 2.5 учитываем только первого подписавшего:
			ДатаПодписи = Неопределено;
			Если Данные.Отправитель.Подписи.Количество() > 0 Тогда
				ДатаПодписи = Данные.Отправитель.Подписи[0].ДатаПодписания;
			КонецЕсли;
			Если Не ЗначениеЗаполнено(ДатаПодписи) Тогда
				ЗаписьВЖурналСобытий(
					Перечисления.УровниСобытийМЭДО.Ошибка,
					Данные.Документ,
					Текст_ОшибкаВДокументе(),
					НСтр("ru = 'В подписях отправителя не обнаружена дата, либо вообще нет подписей'"),
					ДанныеОтвета);
				Возврат;
			КонецЕсли;
			signatory.signed = ДатаПодписи;
			ОтветственнаяСтруктурнаяЕдиница = МЭДОСтруктурыДанных.НовыйОтветственнаяСтруктурнаяЕдиница();
			ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
				ОтветственнаяСтруктурнаяЕдиница,
				Данные.Отправитель.Организация.ОрганизацияСсылка,
				Данные.Отправитель.Исполнитель.КонтактноеЛицоСсылка,
				Данные.ДатаУчетаДокумента,
				ДанныеОтвета);
			ЗаполнитьAnyone(signatory, ОтветственнаяСтруктурнаяЕдиница, ВерсияМЭДО);
			document.signatories = ФабрикаXDTO.Создать(document.Тип().Свойства.Получить("signatories").Тип);
			document.signatories.signatory.Добавить(signatory);
			
			document.addressees = ФабрикаXDTO.Создать(document.Тип().Свойства.Получить("addressees").Тип);
			addressee = НовыйОбъектСообщения("addressee", ВерсияМЭДО);
			Для Каждого Получатель Из Данные.Получатели Цикл
				ОтветственнаяСтруктурнаяЕдиница = МЭДОСтруктурыДанных.НовыйОтветственнаяСтруктурнаяЕдиница();
				ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
					ОтветственнаяСтруктурнаяЕдиница, 
					Получатель.Контрагент.КонтрагентСсылка,
					Получатель.КонтактноеЛицо.КонтактноеЛицоСсылка,
					Данные.ДатаУчетаДокумента,
					ДанныеОтвета);
				ЗаполнитьAnyone(addressee, ОтветственнаяСтруктурнаяЕдиница, ВерсияМЭДО);
				document.addressees.addressee.Добавить(addressee);
			КонецЦикла;
			communication.document = document;
			
			
			// Файлы добавляем только для формата 2.5 - тут единственное место, где можно добавить файлы,
			// контейнера внутри нет.
			Если ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия25
				И ЗначениеЗаполнено(Данные.Файл.ЛокальноеИмя) Тогда
				communication.files = ФабрикаXDTO.Создать(ТипCommunication.Свойства.Получить("files").Тип);
				file1 = НовыйОбъектСообщения("associatedFile", ВерсияМЭДО);
				file1.localName = Данные.Файл.ЛокальноеИмя;
				file1.group = "Текст документа";
				communication.files.file.Добавить(file1);
				Для Каждого Приложение Из Данные.Приложения Цикл
					file1 = НовыйОбъектСообщения("associatedFile", ВерсияМЭДО);
					file1.localName = Приложение.ЛокальноеИмя;
					file1.group = "Текст приложения";
					communication.files.file.Добавить(file1);
				КонецЦикла;
			КонецЕсли;
			
		КонецЕсли;
		
		communication.deliveryIndex = ФабрикаXDTO.Создать(ТипCommunication.Свойства.Получить("deliveryIndex").Тип);
		Для Каждого Получатель Из Данные.Получатели Цикл
			destination = НовыйОбъектСообщения("communicationPartner", ВерсияМЭДО);
			destination.uid = НРег(Получатель.Контрагент.Идентификатор);
			destination.organization = Получатель.Контрагент.Наименование;
			deliveryDestination = НовыйОбъектСообщения("deliveryDestination", ВерсияМЭДО);
			deliveryDestination.destination = destination;
			communication.deliveryIndex.destination.Добавить(deliveryDestination);
		КонецЦикла;
		
		ЗаписьXML = Новый ЗаписьXML();
		ЗаписьXML.ОткрытьФайл(ПолноеИмяФайлаСообщения, "UTF-8");
		ЗаписьXML.ЗаписатьОбъявлениеXML();
		ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, communication, "communication",,, НазначениеТипаXML.Неявное);
		ЗаписьXML.Закрыть();
		
		УдалитьФайлы(Данные.ВременныйКаталог);
		
		
		// Данные для вспомогательного документа "Данные документа МЭДО":
		// Итоговую папку к отправке подкладываем для хранения истории к исходному документу. Для расследования ошибок
		ЗаписьZip = Новый ЗаписьZipФайла();
		ЗаписьZip.Добавить(ПодкаталогСообщения);
		Если ДанныеОтвета.Свойство("Файл") Тогда
			ДанныеОтвета.Файл.ЛокальноеИмя = СтрШаблон("%1.zip", ИдентификаторСообщения);
			ДанныеОтвета.Файл.ДвоичныеДанные = ЗаписьZip.ПолучитьДвоичныеДанные();
		КонецЕсли;
		Данные.Отправлен = Истина;
		Данные.ГотовКОтправке = Ложь;
		ЗаписатьДанныеИсходящегоДокументаМЭДО(Данные.Документ, Данные, ДанныеОтвета);
		
		ЗафиксироватьТранзакцию();
		
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Информация,
			Данные.Документ,
			Текст_ОбъектОтправленУспешно(),
			Текст_ОбъектОтправленУспешно(),
			ДанныеОтвета);
		
		ДанныеОтвета.Успех = Истина;
	Исключение
		ОтменитьТранзакцию();
		
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Временный файл %1. %2'"),
			Путь, ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			Данные.Документ, 
			НСтр("ru='Ошибка записи исходящего сообщения'"),
			ТекстОшибкиПодробно,
			ДанныеОтвета);
		
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

// Определяет список уведомлений, которые требуется отправить через МЭДО.
//
// Параметры:
//  Настройки - Структура - поля:
//   * Организация - ОпределяемыйТип.Организация
//   * КаталогОтправки - Строка
//   * РазмерПорции - Число
//  МассивУведомлений - Массив из ДокументСсылка.УведомлениеМЭДО - Если Неопределено, то все, подлежащие 
//  																отправке по этой организации, 
//																	либо отбор по выбранным уведомлениям.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица с колонками:
//     * ПредметСообщения - ДокументСсылка.УведомлениеМЭДО
//     * ТипУведомления - ПеречислениеСсылка.ТипыУведомленийМЭДО
//     * Документ - ОпределяемыйТип.ПредметМЭДО - Входящий документ
//     * ИдентификаторСообщения - Строка
//     * Состояние - ПеречислениеСсылка.СостоянияДокументовМЭДО - состояние входящего документа.
Функция ИсходящиеУведомленияКОтправке(Настройки, МассивУведомлений = Неопределено) Экспорт
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 9999
		|	Уведомление.Ссылка КАК ПредметСообщения,
		|	Уведомление.ТипУведомления,
		|	Уведомление.Документ,
		|	Уведомление.ИдентификаторУведомления КАК ИдентификаторСообщения,
		|	Состояния.Состояние
		|ИЗ
		|	Документ.УведомлениеМЭДО КАК Уведомление
		|	ЛЕВОЕ СОЕДИНЕНИЕ
		|	РегистрСведений.СостоянияДокументовМЭДО.СрезПоследних(
		|		, Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Входящее)
		|		) КАК Состояния
		|		ПО Уведомление.Документ = Состояния.Документ
		|ГДЕ
		|	Уведомление.ГотовоКОтправке
		|	И НЕ Уведомление.ПометкаУдаления
		|	И НЕ Уведомление.Документ.ПометкаУдаления
		|	И Уведомление.Организация = &Организация
		|	И Уведомление.Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Исходящее)
		|	И &ОтборУведомлений
		|
		|УПОРЯДОЧИТЬ ПО
		|	Уведомление.Дата");
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "9999", "" + Настройки.РазмерПорции);
	Запрос.УстановитьПараметр("Организация", Настройки.Организация);
	Если МассивУведомлений <> Неопределено Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ОтборУведомлений", "Уведомление.Ссылка В (&МассивУведомлений)");
		Запрос.УстановитьПараметр("МассивУведомлений", МассивУведомлений);
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ОтборУведомлений", "ИСТИНА");
	КонецЕсли;
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

// Попытаться определить главный файл среди всех файлов документа, который и будет описан в паспорте контейнера МЭДО
// 
// Параметры:
//  Документ - ОпределяемыйТип.ПредметМЭДО - Документ
// 
// Возвращаемое значение:
//  СправочникСсылка.Файлы - Главный файл, если удалось определить
Функция ПопытатьсяОпределитьГлавныйФайл(Документ) Экспорт
	
	Таблица = ИнтеграцияСМЭДО.ПолучитьОбычныеФайлыДокумента(Документ);
	Если Таблица.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИскомыйФайл = Неопределено;
	КоличествоНайденных = 0;
	Для Каждого СтрокаТаблицы Из Таблица Цикл
		Если СтрНайти(НРег(СтрокаТаблицы.Расширение), "pdf") > 0 Тогда
			КоличествоНайденных = КоличествоНайденных + 1;
			ИскомыйФайл = СтрокаТаблицы.Файл;
		КонецЕсли;
	КонецЦикла;
	Если КоличествоНайденных = 1 Тогда
		Возврат ИскомыйФайл;
	КонецЕсли;
	
	// Файлов больше 1, однозначно понять какой из них главный - не получается:
	Возврат Справочники.Файлы.ПустаяСсылка();
	
КонецФункции

// Гриф доступа в виде структуры для последующей записи ее в файл контейнера.
// 
// Параметры:
//  ГрифДоступа - ОпределяемыйТип.ГрифДоступаМЭДО - Гриф доступа
//  НастройкиОрганизации - Структура - поля соответствуют ресурсам РС НастройкиОрганизацийМЭДО, в том числе:
//   * ГрифОбычнаяИнформация - ОпределяемыйТип.ГрифДоступаМЭДО
//   * ГрифИнформацияОграниченногоРаспространения  - ОпределяемыйТип.ГрифДоступаМЭДО
// 
// Возвращаемое значение:
//  см. МЭДОСтруктурыДанных.НовыйОграниченноеЗначение.
Функция ГрифДоступаВВидеСтруктуры(ГрифДоступа, НастройкиОрганизации) Экспорт
	
	СтруктураГриф = МЭДОСтруктурыДанных.НовыйОграниченноеЗначение();
	
	Если ГрифДоступа = НастройкиОрганизации.ГрифОбычнаяИнформация Тогда
		СтруктураГриф.Идентификатор = "DC00000000";
		СтруктураГриф.Наименование = "Обычная информация";
	ИначеЕсли ГрифДоступа = НастройкиОрганизации.ГрифИнформацияОграниченногоРаспространения Тогда
		СтруктураГриф.Идентификатор = "DC00000001";
		СтруктураГриф.Наименование = "Информация ограниченного распространения";
	КонецЕсли;
	
	Возврат СтруктураГриф;
	
КонецФункции

// Процедура - делает тоже, что и СоздатьЗапись, но в фоновом задании, чтобы если эта запись в журнал осталась, даже
//   если произошла отмента транзакции, из которой вызвана эта процедура.
// 
// На выходе присвоит входной структуре Данные поля:
//   Успех = Ложь
//   СообщениеОбОшибке = Подробный текст ошибки.
//
// Параметры:
//  Уровень - ПеречислениеСсылка.УровниСобытийМЭДО - Уровень: Ошибка, Предупреждение, Информация.
//  Объект - ОпределяемыйТип.ОбъектСОшибкойМЭДО - Объект, с которым связана ошибка.
//  ТекстОшибкиКратко - Строка	 - Краткий текст ошибки
//  ТекстОшибкиПодробно - Строка	 - Подробный текст ошибки
//  ДанныеОтвета - Структура, Неопределено - Если передано Неопределено, то в журнал не писать, 
//  						но просто выдать сообщение. см. МЭДОСтруктурыДанных.НовыйОтвет. 
Процедура ЗаписьВЖурналСобытий(
	Уровень, Объект, ТекстОшибкиКратко, ТекстОшибкиПодробно, ДанныеОтвета = Неопределено) Экспорт
	
	ДатаСобытия = ТекущаяДатаСеанса();
	Сообщение = СтрШаблон(
		НСтр("ru = '%1, %2: %3 // %4 // %5.
		|(см. Журнал событий МЭДО)'"),
		Уровень, ДатаСобытия, Объект, ТекстОшибкиКратко, ТекстОшибкиПодробно);
	
	// Продублировать на экран, если запускает пользователь, а не из регламентного задания:
	Если Не СтандартныеПодсистемыПовтИсп.ЭтоФоновоеЗадание() Тогда
		ОбщегоНазначения.СообщитьПользователю(Сообщение);
	КонецЕсли;
	Если ДанныеОтвета = Неопределено Тогда
		Возврат; // просто выдать сообщение об ошибке на экран и выйти.
	КонецЕсли;
	
	
	СтруктураЗаписи = Новый Структура();
	СтруктураЗаписи.Вставить("Идентификатор",		"" + Новый УникальныйИдентификатор());
	СтруктураЗаписи.Вставить("Уровень",				Уровень);
	СтруктураЗаписи.Вставить("ДатаСобытия",			ДатаСобытия);
	СтруктураЗаписи.Вставить("Объект",				Объект);
	СтруктураЗаписи.Вставить("ТекстОшибкиКратко",	ТекстОшибкиКратко);
	СтруктураЗаписи.Вставить("ТекстОшибкиПодробно",	ТекстОшибкиПодробно);
	
	Если Уровень = Перечисления.УровниСобытийМЭДО.Ошибка Тогда
		ДанныеОтвета.Успех = Ложь;
		ДанныеОтвета.СообщениеОбОшибке = Сообщение;
	КонецЕсли;
	
	Если ТранзакцияАктивна() Тогда
		// Запись в фоне, чтобы даже при дальнейшей отмене транзакции эта запись осталась.
		Аргументы = Новый Массив();
		Аргументы.Добавить(СтруктураЗаписи);
		Аргументы.Добавить(ДанныеОтвета);
		ФоновыеЗадания.Выполнить(
			"МЭДО.ЗаписьВЖурналСобытий_ВФонеИлиНепосредственно",
			Аргументы,
			СтруктураЗаписи.Идентификатор,
			НСтр("ru = 'Запись события МЭДО в журнал'"));
	Иначе
		ЗаписьВЖурналСобытий_ВФонеИлиНепосредственно(СтруктураЗаписи, ДанныеОтвета)
	КонецЕсли;
	
КонецПроцедуры

#Область ТекстовыеКонстанты

// Константа Текст - ошибка в документе.
// 
// Возвращаемое значение:
//  Строка
Функция Текст_ОшибкаВДокументе() Экспорт
	Возврат НСтр("ru = 'Ошибка в исходящем документе'");
КонецФункции

Функция Обозначение_ВнешнийДокумент() Экспорт
	Возврат "DocumentMedo";
КонецФункции

Функция Обозначение_ВнешнийКонтрагент() Экспорт
	Возврат "OrganizationMedo";
КонецФункции

Функция Обозначение_ВнешнееКонтактноеЛицо() Экспорт
	Возврат "ContactPersonMedo";
КонецФункции

#КонецОбласти

// Приводит имя файла к виду [a-zA-Z0-9_]{1,250}.[a-zA-Z0-9]{3,4} - т.е. определенные символы, имя до 250 символов, 
// расширение от 3 до 4 символов.
// 
// Параметры:
//  ИмяФайла - Строка - Исходоное Имя файла
//  РасширениеФайла - Строка - Исходное расширение файла
// 
// Возвращаемое значение:
//  Строка
Функция ЗаменитьНеподходящееИмяФайла(Знач ИмяФайла, Знач РасширениеФайла) Экспорт
	
	ИмяФайла = СокрЛП(СтроковыеФункции.СтрокаЛатиницей(ИмяФайла));
	Если СтрДлина(ИмяФайла) > 250 Тогда
		ИмяФайла = Лев(ИмяФайла, 250);
	КонецЕсли;
	ИмяФайла = ЗаменитьНеподходящиеСимволы(ИмяФайла);
	
	РасширениеФайла = СокрЛП(СтроковыеФункции.СтрокаЛатиницей(РасширениеФайла));
	Если СтрДлина(РасширениеФайла) < 3 Тогда
		РасширениеФайла = РасширениеФайла + "___"; // что гарантированно было больше 3 символов.
	КонецЕсли;
	Если СтрДлина(РасширениеФайла) > 4 Тогда
		РасширениеФайла = Лев(РасширениеФайла, 4);
	КонецЕсли;
	РасширениеФайла = ЗаменитьНеподходящиеСимволы(РасширениеФайла);
	
	Возврат СтрШаблон("%1.%2", ИмяФайла, РасширениеФайла);
	
КонецФункции

// Получить поля организации для заполнения стандартных структур.
// 
// Параметры:
//  Организация		- ОпределяемыйТип.Организация - организация.
//  ДатаСведений	- Дата - На какую дату получить сведения о наименовании (если поддерживается в конфигурации). 
//  						Если передана пустая дата, то будет актуальное наименование.
//  ДанныеОтвета	- см. МЭДОСтруктурыДанных.НовыйОтвет.
// 
// Возвращаемое значение:
//  см. МЭДОСтруктурыДанных.НовыйОрганизация.
Функция ПолучитьПоляОрганизации(Организация, ДатаСведений, ДанныеОтвета) Экспорт
	
	СтруктураОрганизация = МЭДОСтруктурыДанных.НовыйОрганизация();
	
	Настройки = РегистрыСведений.НастройкиОрганизацийМЭДО.ПолучитьНастройки(
		Организация, ДанныеОтвета, "ИдентификаторМЭДО, НаименованиеМЭДО");
	Если Не ДанныеОтвета.Успех Тогда
		Возврат СтруктураОрганизация;
	КонецЕсли;
	
	СтруктураОрганизация.Идентификатор = Настройки.ИдентификаторМЭДО;
	СтруктураОрганизация.Наименование = ИнтеграцияСМЭДО.НаименованиеЮрлицаНаДату(Организация, ДатаСведений);
	СтруктураОрганизация.ОрганизацияСсылка = Организация;
	Возврат СтруктураОрганизация;
	
КонецФункции

// Получить поля организации для заполнения стандартных структур.
// 
// Параметры:
//  Контрагент		- ОпределяемыйТип.КонтрагентМЭДО - контрагент.
//  ДатаСведений	- Дата - На какую дату получить сведения о наименовании (если поддерживается в конфигурации). 
//  						Если передана пустая дата, то будет актуальное наименование.
//  ВыдатьОшибку	- Булево - выдать ошибку, если не заполнены некоторые поля, т.е. если контрагент не настроен 
//  							полностью для обмена по МЭДО. Актуально для исходящих отправок.
//  							
//  ДанныеОтвета	- см. МЭДОСтруктурыДанных.НовыйОтвет.
// 
// Возвращаемое значение:
//  см. МЭДОСтруктурыДанных.НовыйКонтрагент.
Функция ПолучитьПоляКонтрагента(Контрагент, ДатаСведений, ВыдатьОшибку, ДанныеОтвета) Экспорт
	
	СтруктураКонтрагент = МЭДОСтруктурыДанных.НовыйКонтрагент();
	
	Настройки = РегистрыСведений.НастройкиКонтрагентовМЭДО.ПолучитьНастройки(Контрагент, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат СтруктураКонтрагент;
	КонецЕсли;
	
	СтруктураКонтрагент.Идентификатор		= ИнтеграцияСМЭДО.ИдентификаторВнешнегоОбъекта(
		Контрагент, Обозначение_ВнешнийКонтрагент());
	СтруктураКонтрагент.Наименование		= ИнтеграцияСМЭДО.НаименованиеЮрлицаНаДату(Контрагент, ДатаСведений);
	СтруктураКонтрагент.АдресМЭДО			= Настройки.АдресМЭДО;
	СтруктураКонтрагент.ВерсияМЭДО			= Настройки.ВерсияФорматаМЭДО;
	СтруктураКонтрагент.КонтрагентСсылка	= Контрагент;
	
	Если ВыдатьОшибку Тогда
		ТекстОшибкиПодробно = "";
		Если Не ЗначениеЗаполнено(СтруктураКонтрагент.АдресМЭДО) Тогда
			ТекстОшибкиПодробно = ТекстОшибкиПодробно
				+ СтрШаблон(НСтр("ru = 'У контрагента %1 не указан адрес МЭДО.'"), Контрагент) + Символы.ПС;
		КонецЕсли;
		Если Не ЗначениеЗаполнено(СтруктураКонтрагент.Идентификатор) Тогда
			ТекстОшибкиПодробно = ТекстОшибкиПодробно 
				+ СтрШаблон(НСтр("ru = 'У контрагента %1 не указан идентификатор МЭДО'"), Контрагент);
		КонецЕсли;
		Если ТекстОшибкиПодробно <> "" Тогда
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				Контрагент,
				Текст_ОшибкаВКонтрагенте(),
				ТекстОшибкиПодробно,
				ДанныеОтвета);
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураКонтрагент;
	
КонецФункции

#Область ОперацииСКаталогами

// Проверить существует ли каталог.
// 
// Параметры:
//  Путь - Строка - Путь
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
// 
// Возвращаемое значение:
//  Булево - Истина - существует, Ложь - нет.
Функция ПроверитьСуществуетЛиКаталог(Путь, ДанныеОтвета = Неопределено) Экспорт
	
	КаталогНаДиске = Новый Файл(Путь);
	Если НЕ КаталогНаДиске.Существует() Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			Путь,
			Текст_КаталогНеСуществует(),
			СтрШаблон(НСтр("ru = 'Каталог обмена ""%1"" не существует или недоступен с сервера 1С:Предприятия.'"), Путь),
			ДанныеОтвета);
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Создает каталог, если его еще не существует.
// 
// Параметры:
//  Путь - Строка - Путь к каталогу
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
// 
// Возвращаемое значение:
//  Булево - Истина - удалось, Ложь - нет.
Функция СоздатьКаталогЕслиНет(Путь, ДанныеОтвета = Неопределено) Экспорт
	
	ВсеНормально = Истина;
	
	ПутьКаталог = Новый Файл(Путь);
	Если Не ПутьКаталог.Существует() Тогда
		Попытка
			СоздатьКаталог(Путь);
		Исключение
			ТекстОшибкиПодробно = СтрШаблон(НСтр("ru = 'Не удалось создать каталог: ""%1""
				|%2'"),
				Путь,
				ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				Путь,
				НСтр("ru = 'Ошибка создания каталога'"), 
				ТекстОшибкиПодробно,
				ДанныеОтвета);
			ВсеНормально = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Возврат ВсеНормально;
	
КонецФункции

#КонецОбласти

// Обработчик подписки на событие. Синхронизирует данные документа МЭДО с предметом МЭДО - пометку удаления.
// 
// Параметры:
//  Источник - ОпределяемыйТип.ПредметМЭДООбъект - Источник
//  Отказ - Булево - Отказ
Процедура СинхронизироватьДанныеДокументаМЭДОПриЗаписи(Источник, Отказ) Экспорт
	
	Если Не ЗначениеЗаполнено(Источник.Ссылка) Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	ДанныеМЭДО = Документы.ДанныеДокументаМЭДО.ПолучитьДанныеДокументаМЭДО(
		Источник.Ссылка, "Ссылка", Неопределено);
	Если ЗначениеЗаполнено(ДанныеМЭДО.Ссылка) Тогда
		ДанныеМЭДОПометкаУдаления = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ДанныеМЭДО.Ссылка, "ПометкаУдаления");
		
		Если ИнтеграцияСМЭДО.ЭтоВходящийДокумент(Источник) Или ИнтеграцияСМЭДО.ЭтоИсходящийДокумент(Источник) Тогда
			Если ДанныеМЭДОПометкаУдаления <> Источник.ПометкаУдаления Тогда
				ДанныеМЭДООбъект = ДанныеМЭДО.Ссылка.ПолучитьОбъект();
				ДанныеМЭДООбъект.УстановитьПометкуУдаления(Источник.ПометкаУдаления);
			КонецЕсли;
		Иначе
			// В МЭДО участвуют только входящие и исходящие документы, если каким-то образом начала все-таки был создан
			// вспомогательных документ, но потом например изменили вид документа-владельца, теперь вспомогательный
			// не нужен:
			Если ДанныеМЭДОПометкаУдаления <> Истина Тогда
				ДанныеМЭДООбъект = ДанныеМЭДО.Ссылка.ПолучитьОбъект();
				ДанныеМЭДООбъект.УстановитьПометкуУдаления(Истина);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры


#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Читает и обрабатывает Электронное Сообщение Документооборота, полученное через МЭДО.
// 
// Параметры:
//  Файл - Файл - ссылается на ЭСД. Исходный zip-файл с сообщением ЭСД
//  Организация - СправочникСсылка.Организации - Организация
//  ТипКонтента - Строка - принимает значения "Транспортный контейнер" или "Уведомление".
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет. 
// 
Процедура ОбработатьВходящееЭСД(Файл, Организация, ТипКонтента, ДанныеОтвета)
	
	УстановитьПривилегированныйРежим(Истина);
	
	ВременныйКаталог = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ПолучитьИмяВременногоФайла());
	АрхивЭСД = Новый ЧтениеZipФайла(Файл.ПолноеИмя);
	АрхивЭСД.ИзвлечьВсе(ВременныйКаталог, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
	АрхивЭСД.Закрыть();
	
	ФайлыЭСД = НайтиФайлы(ВременныйКаталог, "*.xml");
	
	Если ФайлыЭСД.Количество() = 0 Тогда
		
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			Файл.ПолноеИмя,
			Текст_ОшибкаЧтенияXml(), 
			СтрШаблон(НСтр("ru = 'В файле ЭСД %1 не обнаружено файлов .xml'"), Файл.Имя),
			ДанныеОтвета);
	Иначе
		
		ФайлСообщения = ФайлыЭСД[0];
		Попытка
			
			ВерсияМЭДО = ПрочитатьВерсиюМЭДОИзЭСД(ФайлСообщения.ПолноеИмя, ДанныеОтвета);
			Если ДанныеОтвета.Успех = Ложь Тогда
				УдалитьФайлы(ВременныйКаталог);
				Возврат;
			КонецЕсли;
			
			ПакетXDTO = ПакетXDTOСообщенияПоВерсииМЭДО(ВерсияМЭДО);
			ТипCommunication = ПакетXDTO.КорневыеСвойства.Получить("communication").Тип;
			communication = ПрочитатьXMLФабрикой(ФайлСообщения.ПолноеИмя, ТипCommunication, ДанныеОтвета);
			Если Не ДанныеОтвета.Успех Тогда
				УдалитьФайлы(ВременныйКаталог);
				Возврат;
			КонецЕсли;
			
			type = communication.header.type;
			Если Не (type = "Транспортный контейнер" Или type = "Документ"
				Или type = "Уведомление" Или type = "Квитанция") Тогда
				ЗаписьВЖурналСобытий(
					Перечисления.УровниСобытийМЭДО.Ошибка,
					Файл.ПолноеИмя,
					Текст_ОшибкаЧтенияXml(), 
					СтрШаблон(НСтр("ru = 'Пропущено сообщение неизвестного типа ""%1""'"), type),
					ДанныеОтвета);
				УдалитьФайлы(ВременныйКаталог);
				Возврат;
			КонецЕсли;
			Если ТипКонтента <> Неопределено И СтрНайти(ТипКонтента, type) = 0 Тогда
				// ТипКонтента правильный, но в данный момент загружается другой, просто пропускаем.
				ДанныеОтвета.СообщениеОбОшибке = "ДругойВерныйТипСообщения";
				УдалитьФайлы(ВременныйКаталог);
				Возврат;
			КонецЕсли;
			
			Если type = "Транспортный контейнер" Тогда; // Версия МЭДО 2.7, 2.7.1
				ОбработатьВходящийТранспортныйКонтейнер(ВременныйКаталог, Организация, communication, ДанныеОтвета);
			ИначеЕсли type = "Документ" Тогда // Версия МЭДО 2.2 или 2.5
				ОбработатьВходящийДокумент22_25(ВременныйКаталог, Организация, communication, ДанныеОтвета);
			ИначеЕсли type = "Уведомление" Тогда
				ДвоичныеДанные = Новый ДвоичныеДанные(ФайлСообщения.ПолноеИмя);
				ОбработатьВходящееУведомление(ВременныйКаталог, communication, ДвоичныеДанные, ДанныеОтвета);
			ИначеЕсли type = "Квитанция" Тогда
				ДвоичныеДанные = Новый ДвоичныеДанные(ФайлСообщения.ПолноеИмя);
				ОбработатьВходящуюКвитанцию(ВременныйКаталог, communication, ДвоичныеДанные, ДанныеОтвета);
			Иначе
				ЗаписьВЖурналСобытий(
					Перечисления.УровниСобытийМЭДО.Ошибка,
					Файл.ПолноеИмя,
					Текст_ОшибкаЧтенияXml(), 
					СтрШаблон(НСтр("ru = 'Пропущено сообщение неизвестного типа ""%1""'"), type),
					ДанныеОтвета);
			КонецЕсли;
			
		Исключение
			ТекстОшибкиПодробно = СтрШаблон(
				НСтр("ru = 'Ошибка при загрузке файла %1 - %2'"),
				Файл.ПолноеИмя, ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				Файл.ПолноеИмя,
				Текст_ОшибкаЧтенияXml(),
				ТекстОшибкиПодробно,
				ДанныеОтвета);
		КонецПопытки;
		
	КонецЕсли;
	
	УдалитьФайлы(ВременныйКаталог);
	
КонецПроцедуры

#Область ВходящиеДокументы

// Читает и обрабатывает Электронное Сообщение Документооборота, полученное через МЭДО,
// с документом по формату 2.2 и 2.5.
// 
// Параметры:
//  ВременныйКаталог - Строка - путь к временному каталогу, содержащему документ.
//  Организация - ОпределяемыйТип.Организация - Организация.
//  communication - ОбъектXDTO - содержит данные ЭСД.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
// 
Процедура ОбработатьВходящийДокумент22_25(ВременныйКаталог, Организация, communication, ДанныеОтвета)
	
	ВерсияМЭДО = communication.version;
	
	Если ВерсияМЭДО <> "2.2" И ВерсияМЭДО <> "2.5" Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, 
			ВременныйКаталог,
			НСтр("ru = 'Не поддерживаемая версия'"),
			Текст_ВерсияНеПоддерживается(ВерсияМЭДО, ВременныйКаталог), 
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	ИдентификаторСообщения = communication.header.uid;
	
	// Если ИдентификаторСообщения был обработан ранее - считаем что сообщение пришло повторно по ошибке,
	// но все же загрузим его, с предупреждением.
	Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Состояния.ИдентификаторСообщения КАК ИдентификаторСообщения
		|ИЗ
		|	РегистрСведений.СостоянияДокументовМЭДО.СрезПоследних( , 
		|		Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Входящее)) КАК Состояния
		|ГДЕ
		|	ИдентификаторСообщения = &ИдентификаторСообщения");
	Запрос.УстановитьПараметр("ИдентификаторСообщения", ИдентификаторСообщения);
	РезультатЗапроса = Запрос.Выполнить();
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'ЭСД %1 было обработано ранее, согласно регистру ""Состояния документов МЭДО"".
			|Документ будет перезаписан заново'"), ИдентификаторСообщения);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Предупреждение,
			СтрШаблон(НСтр("ru = 'ЭСД %1  Файл %2'"), ИдентификаторСообщения, ВременныйКаталог),
			НСтр("ru = 'Сообщение уже обработано, загрузка повторно'"), ТекстОшибкиПодробно, ДанныеОтвета);
	КонецЕсли;
	
	
	document = СвойствоXDTOЕслиЕсть(communication, "document", Неопределено);
	Если document = Неопределено Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, 
			ВременныйКаталог,
			НСтр("ru = 'Ошибка во входящем сообщении'"),
			НСтр("ru = 'Для формата 2.2, 2.5 данные о документе берутся из сообщения, а в сообщении не найдено секции ""communication/document""'"),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	
	ДанныеДокумента = МЭДОСтруктурыДанных.НовыйДанныеВходящегоДокументаДляСоздания();
	
	ДанныеДокумента.ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.ЗначениеПоСтроковомуЗначению(ВерсияМЭДО);
	ДанныеДокумента.ИдентификаторДокумента = document.uid;
	ДанныеДокумента.ИдентификаторСообщения = ИдентификаторСообщения;
	ДанныеДокумента.Заголовок = СвойствоXDTOЕслиЕсть(document, "annotation", "");
	ДанныеДокумента.ИсходящаяДата = ЗначениеВДату(СвойствоXDTOЕслиЕсть(document.num, "date", '00010101'));
	ДанныеДокумента.ИсходящийНомер = document.num.number;
	ДанныеДокумента.Содержание = СвойствоXDTOЕслиЕсть(document, "comment", "");
	СтруктураОрганизация = ПолучитьПоляОрганизации(Организация, ДанныеДокумента.ИсходящаяДата, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(ДанныеДокумента.Организация, СтруктураОрганизация);
	
	НачатьТранзакцию();
	Попытка
		СтруктураКонтрагент = ИнтеграцияСМЭДО.НайтиСоздатьКонтрагента(
			communication.header.source.organization,
			communication.header.source.uid,
			ДанныеДокумента.ИсходящаяДата,
			Ложь,
			ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(ДанныеДокумента.Отправитель.Контрагент, СтруктураКонтрагент);
		
		НастройкиКонтрагента = Новый Структура("ВерсияФорматаМЭДО", ДанныеДокумента.ВерсияМЭДО);
		РегистрыСведений.НастройкиКонтрагентовМЭДО.ОбновитьНастройки(
			СтруктураКонтрагент.КонтрагентСсылка, НастройкиКонтрагента);
		
		Если document.signatories.signatory.Количество() <> 0 Тогда
			Если document.signatories.signatory[0].Установлено("person") Тогда
				НаименованиеПодписавшего = communication.document.signatories.signatory[0].person.__content;
				ИдентификаторПодписавшего = 
					СвойствоXDTOЕслиЕсть(document.signatories.signatory[0].person, "id", "");
				Если ЗначениеЗаполнено(НаименованиеПодписавшего) Тогда
					СтруктураКонтактноеЛицо = ИнтеграцияСМЭДО.НайтиСоздатьКонтактноеЛицо(
						ДанныеДокумента.Отправитель.Контрагент,
						НаименованиеПодписавшего,
						ИдентификаторПодписавшего,
						ДанныеДокумента.ИсходящаяДата);
					ЗаполнитьЗначенияСвойств(ДанныеДокумента.Подписал, СтруктураКонтактноеЛицо);
					ЗаполнитьЗначенияСвойств(ДанныеДокумента.Отправитель.КонтактноеЛицо, СтруктураКонтактноеЛицо);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	
		Документ = ИнтеграцияСМЭДО.НайтиСоздатьВходящийДокумент(ДанныеДокумента, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат;
		КонецЕсли;
		
		
		ИнтеграцияСМЭДО.УдалитьФайлыПодписиИСлужебныеФайлы(Документ);// На случай повторной загрузки.
		
		Если ЕстьСвойствоXDTO(communication, "files") Тогда
			Для Каждого file Из communication.files.file Цикл
				КомментарийФайла = СвойствоXDTOЕслиЕсть(file, "description", "");
				ДанныеДокумента.ГлавныйФайл = ИнтеграцияСМЭДО.ПрисоединитьФайл(
					Документ, file.localName, ВременныйКаталог + file.localName, КомментарийФайла, ДанныеОтвета);
			КонецЦикла;
		КонецЕсли;
		
		
		// Данные для вспомогательного документа "Данные документа МЭДО":
		ЗаписатьДанныеВходящегоДокументаМЭДО(Документ, ДанныеДокумента, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			ОтменитьТранзакцию();
			Возврат;
		КонецЕсли;
		
		
		СоздатьИсходящуюКвитанцию(
			ИдентификаторСообщения, Документ, ДанныеДокумента.Отправитель.Контрагент.КонтрагентСсылка, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			ОтменитьТранзакцию();
			Возврат;
		КонецЕсли;
		
		
		ЗафиксироватьТранзакцию();
		
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Информация,
			Документ,
			Текст_ОбъектПолученУспешно(),
			Текст_ОбъектПолученУспешно(),
			ДанныеОтвета);
		
	Исключение
		Если ТранзакцияАктивна() Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		
		ТекстОшибкиПодробно = СтрШаблон(
			"%1 ID=%2 - %3",
			ДанныеДокумента.ИдентификаторДокумента,
			Документ,
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			ДанныеДокумента.ИдентификаторДокумента,
			Текст_ОшибкаЧтенияXml(),
			ТекстОшибкиПодробно,
			ДанныеОтвета);
	КонецПопытки;
	
КонецПроцедуры

// Функция - Читает и обрабатывает Электронное сообщение документооборота, полученное через МЭДО,
// в составе транспортного контейнера по формату 2.7, 2.7.1.
// 
// Параметры:
//  ВременныйКаталог	- Строка - путь к временному каталогу, содержащему communication.
//  Организация			- ОпределяемыйТип.Организация - Организация.
//  communication		- ОбъектXDTO - содержит данные сообщения ЭСД.
//  ДанныеОтвета		- см. МЭДОСтруктурыДанных.НовыйОтвет.
// 
Процедура ОбработатьВходящийТранспортныйКонтейнер(ВременныйКаталог, Организация, communication, ДанныеОтвета)
	
	ВерсияМЭДО = communication.version;
	
	Если ВерсияМЭДО <> "2.7" И ВерсияМЭДО <> "2.7.1" Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			ВременныйКаталог,
			НСтр("ru = 'Не поддерживаемая версия'"),
			Текст_ВерсияНеПоддерживается(ВерсияМЭДО, ВременныйКаталог),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	container = ЗначениеВМассивеXDTO(communication.container);
	
	ПутьКZipФайлу = ВременныйКаталог + container[0].body;
	
	ТранспортныйКонтейнер = Новый ЧтениеZipФайла(ПутьКZipФайлу);
	ВременныйКаталогКонтейнера = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(
		ВременныйКаталог + Новый УникальныйИдентификатор());
	ТранспортныйКонтейнер.ИзвлечьВсе(ВременныйКаталогКонтейнера, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
	ТранспортныйКонтейнер.Закрыть();
	ИмяФайлаКонтейнера = ВременныйКаталогКонтейнера + "passport.xml";
	
	
	ПакетXDTO = ПакетXDTOКонтейнераПоВерсииМЭДО(ВерсияМЭДО); 
	ТипContainer = ПакетXDTO.КорневыеСвойства.Получить("container").Тип;
	
	ПаспортТК = ПрочитатьXMLФабрикой(ИмяФайлаКонтейнера, ТипContainer, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	
	
	ВерсияПаспорта = ПаспортТК.version;
	Если ВерсияПаспорта <> ВерсияПаспортаПоВерсииМЭДО(ВерсияМЭДО) Тогда
		ТекстОшибкиПодробно = СтрШаблон(НСтр(
			"ru = 'Версия транспортного контейнера %1 для версии МЭДО %2 не поддерживается.'"), 
			ВерсияПаспорта, ВерсияМЭДО);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, ИмяФайлаКонтейнера,
			НСтр("ru = 'Не поддерживаемая версия'"), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	ИдентификаторСообщения = communication.header.uid;
	
	
	// Если ЭСД уже было обработано ранее - считаем что нужно обработать заново и перезаписать документ
	Запрос = Новый Запрос( 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Состояния.ИдентификаторСообщения КАК ИдентификаторСообщения
		|ИЗ
		|	РегистрСведений.СостоянияДокументовМЭДО.СрезПоследних( , 
		|		Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Входящее)) КАК Состояния
		|ГДЕ
		|	ИдентификаторСообщения = &ИдентификаторСообщения");
	Запрос.УстановитьПараметр("ИдентификаторСообщения", ИдентификаторСообщения);
	РезультатЗапроса = Запрос.Выполнить();
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'ЭСД %1 было обработано ранее, согласно регистру ""Состояния документов МЭДО"".
			|Документ будет перезаписан заново'"),
			ИдентификаторСообщения);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Предупреждение,
			СтрШаблон(НСтр("ru = 'ЭСД %1  Файл %2'"), ИдентификаторСообщения, ПутьКZipФайлу),
			НСтр("ru = 'Сообщение уже обработано, загрузка повторно'"), ТекстОшибкиПодробно, ДанныеОтвета);
	КонецЕсли;
	
	
	ДанныеДокумента = МЭДОСтруктурыДанных.НовыйДанныеВходящегоДокументаДляСоздания();
	
	ДанныеДокумента.ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.ЗначениеПоСтроковомуЗначению(ВерсияМЭДО);
	ДанныеДокумента.ИдентификаторДокумента = ПаспортТК.uid;
	ДанныеДокумента.ИдентификаторСообщения = ИдентификаторСообщения;
	
	Настройки = РегистрыСведений.НастройкиОрганизацийМЭДО.ПолучитьНастройки(Организация, ДанныеОтвета);
	Если ДанныеОтвета.Успех = Ложь Тогда
		Возврат;
	КонецЕсли;
	
	
	// Гриф доступа:
	Если ЕстьСвойствоXDTO(ПаспортТК.requisites, "classification")
		И ЕстьСвойствоXDTO(ПаспортТК.requisites.classification, "id") Тогда
		КодГрифаДоступа = СокрЛП(ПаспортТК.requisites.classification.id);
		ДанныеДокумента.ГрифДоступа = ГрифДоступаПоКоду(КодГрифаДоступа, Настройки);
	КонецЕсли;
	Если ВерсияМЭДО = "2.7.1" Тогда
		Если Не ЗначениеЗаполнено(КодГрифаДоступа) Тогда
			ТекстОшибкиПодробно =
				НСтр("ru = 'Для формата МЭДО версии 2.7.1 должен быть обязательно указан гриф доступа (поле classification)'");
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				СтрШаблон(НСтр("ru = 'ЭСД %1  Файл %2'"), ИдентификаторСообщения, ПутьКZipФайлу),
				НСтр("ru = 'Ошибка получения грифа доступа'"), ТекстОшибкиПодробно, ДанныеОтвета);
			Возврат;
		ИначеЕсли Не ЗначениеЗаполнено(ДанныеДокумента.ГрифДоступа) Тогда
			ТекстОшибкиПодробно = СтрШаблон(
				НСтр("ru = 'Для формата МЭДО версии 2.7.1 должен быть обязательно указан гриф доступа, его не удалось определить по коду %1 из контейнера'"),
				КодГрифаДоступа);
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				СтрШаблон(НСтр("ru = 'ЭСД %1  Файл %2'"), ИдентификаторСообщения, ПутьКZipФайлу),
				НСтр("ru = 'Ошибка получения грифа доступа'"), ТекстОшибкиПодробно, ДанныеОтвета);
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	
	ДанныеДокумента.Заголовок = ПаспортТК.requisites.annotation;
	
	author = ЗначениеВМассивеXDTO(ПаспортТК.authors.author);
	ДанныеДокумента.ИсходящаяДата = ЗначениеВДату(author[0].registration.date);
	ДанныеДокумента.ИсходящийНомер = author[0].registration.number;
	
	СтруктураОрганизация = ПолучитьПоляОрганизации(Организация, ДанныеДокумента.ИсходящаяДата, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(ДанныеДокумента.Организация, СтруктураОрганизация);
	
	
	document = ПаспортТК.document;
	
	ДанныеДокумента.Содержание = СвойствоXDTOЕслиЕсть(document, "description", "");
	
	НачатьТранзакцию();
	Попытка
		СтруктураКонтрагент = ИнтеграцияСМЭДО.НайтиСоздатьКонтрагента(
			communication.header.source.organization,
			communication.header.source.uid,
			ДанныеДокумента.ИсходящаяДата,
			Ложь,
			ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат;
		КонецЕсли;
		
		НастройкиКонтрагента = Новый Структура("ВерсияФорматаМЭДО", ДанныеДокумента.ВерсияМЭДО);
		РегистрыСведений.НастройкиКонтрагентовМЭДО.ОбновитьНастройки(
			СтруктураКонтрагент.КонтрагентСсылка, НастройкиКонтрагента);
		
		ЗаполнитьЗначенияСвойств(ДанныеДокумента.Отправитель.Контрагент, СтруктураКонтрагент);
		sign = ЗначениеВМассивеXDTO(author[0].sign);
		СтруктураКонтактноеЛицо = ИнтеграцияСМЭДО.НайтиСоздатьКонтактноеЛицо(
			ДанныеДокумента.Отправитель.Контрагент, sign[0].person.name, "", ДанныеДокумента.ИсходящаяДата);
		ЗаполнитьЗначенияСвойств(ДанныеДокумента.Подписал, СтруктураКонтактноеЛицо);
		ЗаполнитьЗначенияСвойств(ДанныеДокумента.Отправитель.КонтактноеЛицо, СтруктураКонтактноеЛицо);
		
		ДанныеДокумента.КоличествоЛистов = СвойствоXDTOЕслиЕсть(document, "pagesQuantity", 0);
		
		ДанныеДокумента.КоличествоПриложений = 0;
		attachment = Новый Массив();
		Если ЕстьСвойствоXDTO(ПаспортТК, "attachments") И ЕстьСвойствоXDTO(ПаспортТК.attachments, "attachment") Тогда
			attachment = ЗначениеВМассивеXDTO(ПаспортТК.attachments.attachment);
			ДанныеДокумента.КоличествоПриложений = attachment.Количество();
		КонецЕсли;
		
		ДанныеДокумента.Адресаты = Новый Массив();
		Если ЕстьСвойствоXDTO(ПаспортТК, "addressees") И ЕстьСвойствоXDTO(ПаспортТК, "addressee") Тогда
			
			addressee = ЗначениеВМассивеXDTO(ПаспортТК.addressees.addressee);
			Для Каждого Адресат Из addressee Цикл
				СтруктураАдресата = МЭДОСтруктурыДанных.НовыйСтруктураАдресата();
				
				ЕстьХотьОдно = Ложь;
				Если ЕстьСвойствоXDTO(Адресат, "organization") 
					И ЕстьСвойствоXDTO(Адресат.organization, "title") Тогда
					СтруктураАдресата.Организация = Адресат.organization.title;
					ЕстьХотьОдно = Истина;
				КонецЕсли;
				
				Если ЕстьСвойствоXDTO(Адресат, "department")
					И ЕстьСвойствоXDTO(Адресат.department, "__content") Тогда 
					СтруктураАдресата.Департамент = Адресат.department.__content;
					ЕстьХотьОдно = Истина;
				КонецЕсли;
				
				Если ЕстьСвойствоXDTO(Адресат, "person") Тогда
					person = ЗначениеВМассивеXDTO(Адресат.person); 
					Если person.Количество() > 0 И ЕстьСвойствоXDTO(person[0], "name") Тогда
						СтруктураАдресата.Персона = person[0].name;
					КонецЕсли;
				КонецЕсли;
				
				Если ЕстьХотьОдно Тогда
					ДанныеДокумента.Адресаты.Добавить(СтруктураАдресата);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		
		Документ = ИнтеграцияСМЭДО.НайтиСоздатьВходящийДокумент(ДанныеДокумента, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			ОтменитьТранзакцию();
			Возврат;
		КонецЕсли;
		
		
		// Основной файл документа контейнера и подписи к нему:
		ПутьКФайлуОригиналу = ВременныйКаталогКонтейнера + document.localName;
		ОписаниеФайла = ?(ЕстьСвойствоXDTO(document, "description"), document.description, "");
		ДанныеДокумента.ГлавныйФайл = ИнтеграцияСМЭДО.ПрисоединитьФайл(
			Документ, document.localName, ПутьКФайлуОригиналу, ОписаниеФайла, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			ОтменитьТранзакцию();
			Возврат;
		КонецЕсли;
		
		ИнтеграцияСМЭДО.УдалитьФайлыПодписиИСлужебныеФайлы(Документ); // На случай повторной загрузки.
		
		КартинкиСПоложениями = Новый Массив();
		Для Каждого Автор Из author Цикл
			Положение = СоздатьПоложениеИзображения(Автор.registration.registrationStamp.position);
			ПутьККартинке = ВременныйКаталогКонтейнера + Автор.registration.registrationStamp.localName;
			ИнтеграцияСМЭДО.ЗаписатьРегистрационныйШтамп(Документ, ПутьККартинке, Положение);
			
			ПутьИПоложение = Новый Структура("Путь, Положение", ПутьККартинке, Положение);
			КартинкиСПоложениями.Добавить(ПутьИПоложение);
			
			sign = ЗначениеВМассивеXDTO(Автор.sign);
			НомерПодписи = 0;
			Для Каждого Подпись Из sign Цикл
				Положение = СоздатьПоложениеИзображения(Подпись.documentSignature.signatureStamp.position);
				ПутьККартинке = ВременныйКаталогКонтейнера + Подпись.documentSignature.signatureStamp.localName;
				
				ПутьИПоложение = Новый Структура("Путь, Положение", ПутьККартинке, Положение);
				КартинкиСПоложениями.Добавить(ПутьИПоложение);
				
				ИдентификаторПодписи = ИнтеграцияСМЭДО.ЗаписатьВнешнююЭП(
					ДанныеДокумента.ГлавныйФайл, 
					ВременныйКаталогКонтейнера + Подпись.documentSignature.localName);
				
				Если Не ЗначениеЗаполнено(ИдентификаторПодписи) Тогда
					ТекстОшибкиПодробно = СтрШаблон(
						НСтр("ru = 'Не удалось получить идентификатор подписи для главного файла документа %1 - ID=%2 - %3'"), 
						ДанныеДокумента.Заголовок, ДанныеДокумента.ИдентификаторДокумента, 
					);
					ЗаписьВЖурналСобытий(
						Перечисления.УровниСобытийМЭДО.Ошибка, ПутьКZipФайлу,
						Текст_ОшибкаЧтенияXml(), ТекстОшибкиПодробно, ДанныеОтвета);
					ОтменитьТранзакцию();
					Возврат;
				КонецЕсли;
				
				НомерПодписи = НомерПодписи + 1;
				ИнтеграцияСМЭДО.ЗаписатьОтметкуЭП(
					Документ, "" + ИдентификаторПодписи, ПутьККартинке, НомерПодписи, Положение);
				
			КонецЦикла;
		КонецЦикла;
		
		
		// Файлы-приложения к документу, если они есть, и подписи к ним:
		Для Каждого Приложение Из attachment Цикл
			ОписаниеФайла = ?(ЕстьСвойствоXDTO(Приложение, "description"), Приложение.description, "");
			
			ФайлСсылка = ИнтеграцияСМЭДО.ПрисоединитьФайл(
				Документ, Приложение.localName, ВременныйКаталогКонтейнера + Приложение.localName, ОписаниеФайла, ДанныеОтвета);
			
			Если Не ДанныеОтвета.Успех Тогда
				ОтменитьТранзакцию();
				Возврат;
			КонецЕсли;
			
			Если ЕстьСвойствоXDTO(Приложение, "signature") Тогда
				signature = ЗначениеВМассивеXDTO(Приложение.signature);
				Для Каждого Подпись Из signature Цикл
					ИнтеграцияСМЭДО.ЗаписатьВнешнююЭП(
						ФайлСсылка, ВременныйКаталогКонтейнера + Подпись.localName);
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
		
		
		// Данные для вспомогательного документа "Данные документа МЭДО":
		КодМЭДО = "";
		ДанныеДокумента.ВидДокумента = Справочники.ВидыДокументовМЭДО.ПустаяСсылка();
		Если ЕстьСвойствоXDTO(ПаспортТК.requisites, "documentKind")
			И ЕстьСвойствоXDTO(ПаспортТК.requisites.documentKind, "id") Тогда
			КодМЭДО = ПаспортТК.requisites.documentKind.id;
			ДанныеДокумента.ВидДокумента = Справочники.ВидыДокументовМЭДО.НайтиВидДокумента(
				КодМЭДО, ПаспортТК.requisites.documentKind.__content);
		КонецЕсли;
		КодМЭДО = "";
		ДанныеДокумента.МестоСоставления = Справочники.МестаСоставленияДокументовМЭДО.ПустаяСсылка();
		Если ЕстьСвойствоXDTO(ПаспортТК.requisites, "documentPlace")
			И ЕстьСвойствоXDTO(ПаспортТК.requisites.documentPlace, "id") Тогда
			КодМЭДО = ПаспортТК.requisites.documentPlace.id;
			ДанныеДокумента.МестоСоставления = Справочники.МестаСоставленияДокументовМЭДО.НайтиМестоСоставления(
				КодМЭДО, ПаспортТК.requisites.documentPlace.__content);
		КонецЕсли;
		ЗаписатьДанныеВходящегоДокументаМЭДО(Документ, ДанныеДокумента, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			ОтменитьТранзакцию();
			Возврат;
		КонецЕсли;
		
		
		СоздатьИсходящуюКвитанцию(
			ИдентификаторСообщения, Документ, ДанныеДокумента.Отправитель.Контрагент.КонтрагентСсылка, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			ОтменитьТранзакцию();
			Возврат;
		КонецЕсли;
		
		
		ЗафиксироватьТранзакцию();
		
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Информация,
			Документ,
			Текст_ОбъектПолученУспешно(),
			Текст_ОбъектПолученУспешно(),
			ДанныеОтвета);
		
	Исключение
		Если ТранзакцияАктивна() Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Документ %1 - ID=%2 - %3'"), 
			ДанныеДокумента.Заголовок, ДанныеДокумента.ИдентификаторДокумента, 
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, ПутьКZipФайлу,
			Текст_ОшибкаЧтенияXml(), ТекстОшибкиПодробно, ДанныеОтвета);
	КонецПопытки;
	
КонецПроцедуры

// Определяет гриф доступа по коду из МЭДО.
// 
// Параметры:
//  КодГрифаДоступа - Строка
//  НастройкиОрганизации - Структура - поля соответствуют ресурсам РС НастройкиОрганизацийМЭДО, в том числе:
//   * ГрифОбычнаяИнформация - СправочникСсылка.ГрифыДоступа
//   * ГрифИнформацияОграниченногоРаспространения  - СправочникСсылка.ГрифыДоступа
// 
// Возвращаемое значение:
//  Произвольный, СправочникСсылка.ГрифыДоступа - Гриф доступа по коду
Функция ГрифДоступаПоКоду(КодГрифаДоступа, НастройкиОрганизации)
	
	Если КодГрифаДоступа = "DC00000000" Тогда 
		Возврат НастройкиОрганизации.ГрифОбычнаяИнформация;
	ИначеЕсли КодГрифаДоступа = "DC00000001" Тогда
		Возврат НастройкиОрганизации.ГрифИнформацияОграниченногоРаспространения;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Функция - Создать положение изображения с путем к картинке - промежуточную структуру для наложения штампов.
//
// Параметры:
//  position - ОбъектXDTO - Часть дерева, описывающего файл, начиная от ветки position
// 
// Возвращаемое значение:
//  см. ИнтеграцияСМЭДО.НовыйПоложениеИзображения.
//
Функция СоздатьПоложениеИзображения(position)
	
	Положение = ИнтеграцияСМЭДО.НовыйПоложениеИзображения();
	Положение.Страница	= Число(position.page);
	Положение.Сверху	= Число(position.topLeft.y);
	Положение.Слева		= Число(position.topLeft.x);
	Положение.Ширина	= Число(position.dimension.w);
	Положение.Высота	= Число(position.dimension.h);
	
	Возврат Положение;
	
КонецФункции

// Вспомогательный документ "Данные документа МЭДО" для хранения дополнительных данных МЭДО,
// отсутствующих в основном документе
// 
// Параметры:
//  Документ - ОпределяемыйТип.ПредметМЭДО
//  ДанныеДокумента - см. МЭДОСтруктурыДанных.НовыйДанныеВходящегоДокументаДляСоздания.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ЗаписатьДанныеВходящегоДокументаМЭДО(Документ, ДанныеДокумента, ДанныеОтвета)
	
	ДанныеОбъект = Документы.ДанныеДокументаМЭДО.ПолучитьОбъектДанныхДокумента(Документ, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(
		ДанныеОбъект, ДанныеДокумента,
		"ВерсияМЭДО, ВидДокумента, ГлавныйФайл, ГрифДоступа, ИдентификаторДокумента, ИдентификаторСообщения, 
		|МестоСоставления");
	ДанныеОбъект.Направление = Перечисления.НаправленияСообщенийМЭДО.Входящее;
	ДанныеОбъект.Организация = ДанныеДокумента.Организация.ОрганизацияСсылка;
	Документы.ДанныеДокументаМЭДО.ЗаписатьОбъектДанныхДокумента(ДанныеОбъект, ДанныеОтвета);
	
КонецПроцедуры

#КонецОбласти

#Область ВходящиеУведомленияИКвитанции

// Обрабатывает входящее сообщение, соответствующее уведомлению.
//
Процедура ОбработатьВходящееУведомление(ВременныйКаталог, communication, ДвоичныеДанныеЭСД, ДанныеОтвета)
	
	notification = communication.notification;
	
	ИдентификаторУведомления = communication.header.uid;
	ИдентификаторИсходящегоСообщения = СвойствоXDTOЕслиЕсть(notification, "mid", "");
	ИдентификаторДокумента = notification.uid;
	Документ = ИнтеграцияСМЭДО.ПолучитьДокументПоИдентификатору(ИдентификаторДокумента);


	Если Не ЗначениеЗаполнено(Документ) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Во входящем уведомлении ID=%1 по исх.сообщению %2 указан идентификатор %3,
			|но по нему не обнаружено документа в нашей ИБ...
			|Временный каталог %4'"), 
			ИдентификаторУведомления, ИдентификаторИсходящегоСообщения, ИдентификаторДокумента, ВременныйКаталог);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Документ,
			Текст_ОшибкаЗагрузкиВходящегоУведомления(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	ТипУведомленияИзСообщения = notification.type;
	ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ЗначениеПоСтроковомуЗначению(ТипУведомленияИзСообщения);
	Если Не ЗначениеЗаполнено(ТипУведомления) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Во входящем уведомлении ID=%1 по исх.сообщению %2
			|не удалось разобрать тип уведомления - указано ""%3""
			|Документ %4'"), 
			ИдентификаторУведомления, ИдентификаторИсходящегоСообщения, ТипУведомленияИзСообщения, Документ);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Документ,
			Текст_ОшибкаЗагрузкиВходящегоУведомления(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	ДатаУведомления = ЗначениеВДату(СвойствоXDTOЕслиЕсть(communication.header , "created", '00010101'));
	
	
	// Проверим соответствие идентификаторов данным нашей ИБ.
	СтруктураСостояния = РегистрыСведений.СостоянияДокументовМЭДО.ПолучитьСостояниеДокумента(
		Документ, Перечисления.СостоянияДокументовМЭДО.ДокументОтправлен, "ИдентификаторСообщения", ДатаУведомления);
	Если Не ЗначениеЗаполнено(СтруктураСостояния.ИдентификаторСообщения) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Получено входящее уведомление ID=%1 с исх.сообщением %2,
			|На документ %3, сведения об отправке которого отсутствуют в нашей ИБ.'"),
			ИдентификаторУведомления, ИдентификаторИсходящегоСообщения, Документ);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Документ, 
			Текст_ОшибкаЗагрузкиВходящегоУведомления(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ИдентификаторИсходящегоСообщения) Тогда
		// получим идентификатор исходящего сообщения по данным нашей ИБ.
		ИдентификаторИсходящегоСообщения = СтруктураСостояния.ИдентификаторСообщения;
	КонецЕсли;
	
	
	Реквизиты = ИнтеграцияСМЭДО.ПолучитьТребуемыеДанныеИсходящегоДокумента(
		Документ, "Организация, ДатаУчетаДокумента, Контрагент", ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(Реквизиты.Контрагент) Тогда
		ТекстОшибкиПодробно = СтрШаблон(НСтр(
			"ru = 'Не удалось найти контрагента в исходящем документе %1
			|из входящего уведомления %2, идент.исх.сообщения %3'"),
			Документ, ИдентификаторУведомления, ИдентификаторИсходящегоСообщения);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Документ, 
			Текст_ОшибкаЗагрузкиВходящегоУведомления(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	
	// Уведомление каждый раз создается заново, т.к. может быть много уведомлений по документу
	Уведомление = Документы.УведомлениеМЭДО.СоздатьДокумент();
	Уведомление.Дата = ТекущаяДатаСеанса();
	Уведомление.ИсходящаяДата = ДатаУведомления;
	Уведомление.ТипУведомления = ТипУведомления;
	Уведомление.Направление = Перечисления.НаправленияСообщенийМЭДО.Входящее;
	Уведомление.Заполнить(Неопределено);
	Уведомление.Организация = Реквизиты.Организация;
	Уведомление.Контрагент = Реквизиты.Контрагент;
	Уведомление.Документ = Документ;
	Уведомление.ИдентификаторДокумента = НРег(ИдентификаторДокумента);
	Уведомление.ИдентификаторИсходящегоСообщения = ИдентификаторИсходящегоСообщения;
	Уведомление.ИдентификаторУведомления = communication.header.uid;
	Уведомление.ДанныеСообщения = Новый ХранилищеЗначения(ДвоичныеДанныеЭСД);
	Уведомление.ПометкаУдаления = Ложь;
	Уведомление.Комментарий = СвойствоXDTOЕслиЕсть(notification, "comment", "");
	
	НачатьТранзакцию();
	Попытка
		
		Если ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОПостановкеНаКонтроль
			И ЕстьСвойствоXDTO(notification, "documentSent") Тогда
			
			documentSent = notification.documentSent;
			Уведомление.ПостановкаНаКонтроль.Очистить();
			Уведомление.ПостановкаНаКонтроль_КонтрольныеПунктыДокумента.Очистить();
			НоваяСтрока = Уведомление.ПостановкаНаКонтроль.Добавить();
			НоваяСтрока.ТребуетсяРегистрация = documentSent.needRegistration;
			НоваяСтрока.ТребуетсяИсполнение = documentSent.needExecution;
			НоваяСтрока.ТребуетсяПубликация = documentSent.needPublication;
			clauses = СвойствоXDTOЕслиЕсть(documentSent, "clauses", Неопределено);
			Если clauses <> Неопределено И ЕстьСвойствоXDTO(clauses, "clause") Тогда
				clause = ЗначениеВМассивеXDTO(clauses.clause);
				ПунктыДокумента = Новый Массив();
				Для Каждого claus_i Из clause Цикл
					Пункт = ПрочитатьDocumentClause(claus_i, Реквизиты.ДатаУчетаДокумента, ДанныеОтвета);
					ПунктыДокумента.Добавить(Пункт);
					Если ЗначениеЗаполнено(НоваяСтрока.ПунктыДокументаПредставление)
						И ЗначениеЗаполнено(Пункт.ПолноеПредставление) Тогда
						НоваяСтрока.ПунктыДокументаПредставление = НоваяСтрока.ПунктыДокументаПредставление + Символы.ПС;
					КонецЕсли;
					НоваяСтрока.ПунктыДокументаПредставление = НоваяСтрока.ПунктыДокументаПредставление
						+ ЗаполненноеЗначениеСтрокой("", Пункт.ПолноеПредставление, Символы.ПС, "");
					
					НоваяСтрокаПункт = Уведомление.ПостановкаНаКонтроль_КонтрольныеПунктыДокумента.Добавить();
					ЗаполнитьЗначенияСвойств(
						НоваяСтрокаПункт, Пункт, 
						"НомерПоПорядку, ИдентификаторПункта, Наименование, ТекстПункта, СрокИсполнения, Комментарий");
					НоваяСтрокаПункт.Юрлицо = Пункт.Ответственный.ЮрлицоСсылка;
					НоваяСтрокаПункт.Ответственный = Пункт.Ответственный.КонтактноеЛицоСсылка;
					НоваяСтрокаПункт.ОтветственныйПредставление = Пункт.ПолноеПредставление;
				КонецЦикла;
			КонецЕсли;
			
			СтруктураПредставление = МЭДОСтруктурыДанных.НовыйПостановкаНаКонтроль();
			ЗаполнитьЗначенияСвойств(
				СтруктураПредставление, НоваяСтрока, "ТребуетсяРегистрация, ТребуетсяИсполнение, ТребуетсяПубликация");
			СтруктураПредставление.ПунктыДокумента = ПунктыДокумента;
			
		ИначеЕсли ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОРегистрации
			И ЕстьСвойствоXDTO(notification, "documentAccepted") Тогда
			
			Уведомление.Регистрация.Очистить();
			НоваяСтрока = Уведомление.Регистрация.Добавить();
			НоваяСтрока.РегистрационныйНомер = notification.documentAccepted.num.number;
			НоваяСтрока.ДатаРегистрации = notification.documentAccepted.num.date;
			
			ИнтеграцияСМЭДО.ЗаписатьВИсходящийДокументРегистрациюКонтрагента(
				Документ,
				Реквизиты.Контрагент,
				НоваяСтрока.РегистрационныйНомер,
				НоваяСтрока.ДатаРегистрации,
				ДанныеОтвета);
			
		ИначеЕсли ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОбОтказеВРегистрации
			И ЕстьСвойствоXDTO(notification, "documentRefused") Тогда
			
			ИменаПредопределенных = Метаданные.Справочники.ПричиныОтказаВРегистрацииМЭДО.ПолучитьИменаПредопределенных();
			УдалосьНайти = Ложь;
			ПричинаОтказа = Неопределено;
			ПричинаОтказаИзСообщения = ЗначениеВМассивеXDTO(notification.documentRefused.reason)[0];
			Для Каждого ИмяПредопределенного Из ИменаПредопределенных Цикл
				ПричинаОтказа = Справочники.ПричиныОтказаВРегистрацииМЭДО[ИмяПредопределенного];
				Если ПричинаОтказа.Наименование = ПричинаОтказаИзСообщения Тогда
					Уведомление.ОтказВРегистрации.Очистить();
					НоваяСтрока = Уведомление.ОтказВРегистрации.Добавить();
					НоваяСтрока.ПричинаОтказа = ПричинаОтказа;
					УдалосьНайти = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не УдалосьНайти Тогда 
				НоваяСтрока = Уведомление.ОтказВРегистрации.Добавить();
				НоваяСтрока.ПричинаОтказа = Справочники.ПричиныОтказаВРегистрацииМЭДО.НеРаспознана;
				Уведомление.Комментарий = Уведомление.Комментарий + Символы.ПС
					+ СтрШаблон(НСтр("ru = 'Не распознанная причина отказа: %1'"), ПричинаОтказаИзСообщения);// причина строкой, не распознанная, добавим в комментарий.
			КонецЕсли;
			
		ИначеЕсли ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОПринятииКИсполнению
			И ЕстьСвойствоXDTO(notification, "executorAssigned") Тогда
			
			executorAssigned = notification.executorAssigned;
			
			Уведомление.ПринятиеКИсполнению.Очистить();
			НоваяСтрока = Уведомление.ПринятиеКИсполнению.Добавить();
			
			СтруктураПредставление = МЭДОСтруктурыДанных.НовыйПринятиеКИсполнению();
			
			secretary = СвойствоXDTOЕслиЕсть(executorAssigned, "secretary", Неопределено);
			Если secretary <> Неопределено Тогда
				РуководительСекретарь = ПрочитатьAnyone(secretary, Реквизиты.ДатаУчетаДокумента, ДанныеОтвета);
				Если ЗначениеЗаполнено(РуководительСекретарь.ЮрлицоСсылка) Тогда
					НоваяСтрока.Юрлицо = РуководительСекретарь.ЮрлицоСсылка;
				КонецЕсли;
				НоваяСтрока.РуководительСекретарь = РуководительСекретарь.КонтактноеЛицоСсылка;
				Комментарий = СвойствоXDTOЕслиЕсть(secretary, "comment", "");
				НоваяСтрока.КомментарийРуководителяСекретаря = Комментарий;
				НоваяСтрока.РуководительСекретарьПредставление = 
					НСтр("ru = 'Руководитель/секретарь учреждения'") + Символы.ПС
					+ РуководительСекретарь.ПолноеПредставление
					+ ЗаполненноеЗначениеСтрокой(НСтр("ru = 'Комментарий:'"), Комментарий, "");
				СтруктураПредставление.РуководительСекретарь = РуководительСекретарь;
			КонецЕсли;
			
			manager = СвойствоXDTOЕслиЕсть(executorAssigned, "manager", Неопределено);
			Если manager <> Неопределено Тогда
				РуководительПодразделения = ПрочитатьAnyone(manager, Реквизиты.ДатаУчетаДокумента, ДанныеОтвета);
				Если ЗначениеЗаполнено(РуководительПодразделения.ЮрлицоСсылка) Тогда
					// Если даже заполнено выше, то конкретизируем нижестоящим ведомством
					НоваяСтрока.Юрлицо = РуководительПодразделения.ЮрлицоСсылка;
				КонецЕсли;
				НоваяСтрока.РуководительПодразделения = РуководительПодразделения.КонтактноеЛицоСсылка;
				Комментарий = СвойствоXDTOЕслиЕсть(manager, "comment", "");
				НоваяСтрока.КомментарийРуководителяПодразделения = Комментарий;
				НоваяСтрока.РуководительПодразделенияПредставление =
					НСтр("ru = 'Руководитель подразделения'") + Символы.ПС
					+ РуководительПодразделения.ПолноеПредставление
					+ ЗаполненноеЗначениеСтрокой(НСтр("ru = 'Комментарий:'"), Комментарий, "");
				СтруктураПредставление.РуководительПодразделения = РуководительПодразделения;
			КонецЕсли;
			
			executor = СвойствоXDTOЕслиЕсть(executorAssigned, "executor", Неопределено);
			Если executor <> Неопределено Тогда
				Исполнитель = ПрочитатьAnyone(executor, Реквизиты.ДатаУчетаДокумента, ДанныеОтвета);
				Если ЗначениеЗаполнено(Исполнитель.ЮрлицоСсылка) Тогда
					// Если даже заполнено выше, то конкретизируем нижестоящим ведомством
					НоваяСтрока.Юрлицо = Исполнитель.ЮрлицоСсылка;
				КонецЕсли;
				НоваяСтрока.Исполнитель = Исполнитель.КонтактноеЛицоСсылка;
				Комментарий = СвойствоXDTOЕслиЕсть(manager, "comment", "");
				НоваяСтрока.КомментарийИсполнителя = Комментарий;
				НоваяСтрока.ИсполнительПредставление =
					НСтр("ru = 'Исполнитель'") + Символы.ПС
					+ Исполнитель.ПолноеПредставление
					+ ЗаполненноеЗначениеСтрокой(НСтр("ru = 'Комментарий:'"), Комментарий, "");
				СтруктураПредставление.Исполнитель = Исполнитель;
			КонецЕсли;
			
			СтруктураПредставление.ЮрлицоСсылка = НоваяСтрока.Юрлицо;
			
		ИначеЕсли ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОПодготовкеДоклада 
			И ЕстьСвойствоXDTO(notification, "reportPrepared") Тогда
			
			reportPrepared = notification.reportPrepared;
			signatory = СвойствоXDTOЕслиЕсть(reportPrepared, "signatory", Неопределено);
			Если signatory <> Неопределено Тогда
				Уведомление.ПодготовкаДоклада.Очистить();
				НоваяСтрока = Уведомление.ПодготовкаДоклада.Добавить();
				НоваяСтрока.ДатаПодписания = ЗначениеВДату(СвойствоXDTOЕслиЕсть(signatory, "signed", Неопределено));
				Комментарий = СвойствоXDTOЕслиЕсть(signatory, "comment", "");
				НоваяСтрока.КомментарийПодписания = Комментарий;
				
				Ответственный = ПрочитатьAnyone(signatory, Реквизиты.ДатаУчетаДокумента, ДанныеОтвета);
				НоваяСтрока.Юрлицо = Ответственный.ЮрлицоСсылка;
				НоваяСтрока.Ответственный = Ответственный.КонтактноеЛицоСсылка;
				НоваяСтрока.ОтветственныйПредставление = Ответственный.ПолноеПредставление
					+ ЗаполненноеЗначениеСтрокой(НСтр("ru = 'Комментарий:'"), Комментарий, "");
				
				СтруктураПредставление = МЭДОСтруктурыДанных.НовыйПодготовкаДоклада();
				СтруктураПредставление.Ответственный = Ответственный;
				СтруктураПредставление.ДатаПодписания = НоваяСтрока.ДатаПодписания;
				СтруктураПредставление.КомментарийПодписания = Комментарий;
			КонецЕсли;
			
		ИначеЕсли ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОНаправленииДоклада
			И ЕстьСвойствоXDTO(notification, "reportSent") Тогда
			
			reportSent = notification.reportSent;
			
			report = СвойствоXDTOЕслиЕсть(reportSent, "report", Неопределено);
			Если report <> Неопределено Тогда
				Уведомление.НаправлениеДоклада.Очистить();
				НоваяСтрока = Уведомление.НаправлениеДоклада.Добавить();
				СведенияОДокументе = ПрочитатьDocumentReference(report, Реквизиты.ДатаУчетаДокумента, ДанныеОтвета);
				НоваяСтрока.Юрлицо = СведенияОДокументе.ЮрлицоСсылка;
				НоваяСтрока.Ответственный = СведенияОДокументе.КонтактноеЛицоСсылка;
				НоваяСтрока.РегистрационныйНомер = СведенияОДокументе.РегистрационныеДанные.РегистрационныйНомер;
				НоваяСтрока.ДатаРегистрации = СведенияОДокументе.РегистрационныеДанные.ДатаРегистрации;
				НоваяСтрока.Комментарий = СведенияОДокументе.Комментарий;
				НоваяСтрока.ОтветственныйПредставление = СведенияОДокументе.ПолноеПредставление;
				
				СтруктураПредставление = МЭДОСтруктурыДанных.НовыйНаправлениеДоклада();
				СтруктураПредставление.СведенияОДокументе = СведенияОДокументе;
			КонецЕсли;
			
		ИначеЕсли ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОХодеИсполнения
			И ЕстьСвойствоXDTO(notification, "courseChanged") Тогда
			
			courseChanged = notification.courseChanged;
			
			Уведомление.ХодИсполнения.Очистить();
			НоваяСтрока = Уведомление.ХодИсполнения.Добавить();
			НоваяСтрока.ОписаниеХодаИсполнения = courseChanged.courseText;
			
			reference = СвойствоXDTOЕслиЕсть(courseChanged, "reference", Неопределено);
			СведенияОДокументе = МЭДОСтруктурыДанных.НовыйСведенияОДокументе();
			Если reference <> Неопределено Тогда
				СведенияОДокументе = ПрочитатьDocumentReference(
					reference, Реквизиты.ДатаУчетаДокумента, ДанныеОтвета);
				НоваяСтрока.Юрлицо = СведенияОДокументе.ЮрлицоСсылка;
				НоваяСтрока.Ответственный = СведенияОДокументе.КонтактноеЛицоСсылка;
				НоваяСтрока.РегистрационныйНомер = СведенияОДокументе.РегистрационныеДанные.РегистрационныйНомер;
				НоваяСтрока.ДатаРегистрации = СведенияОДокументе.РегистрационныеДанные.ДатаРегистрации;
				НоваяСтрока.Комментарий = СведенияОДокументе.Комментарий;
				НоваяСтрока.ОтветственныйПредставление = СведенияОДокументе.ПолноеПредставление;
			КонецЕсли;
			
			СтруктураПредставление = МЭДОСтруктурыДанных.НовыйХодИсполнения();
			СтруктураПредставление.СведенияОДокументе = СведенияОДокументе;
			СтруктураПредставление.ОписаниеХодаИсполнения = НоваяСтрока.ОписаниеХодаИсполнения;
			
		ИначеЕсли ТипУведомления = Перечисления.ТипыУведомленийМЭДО.ОбОпубликовании
			И ЕстьСвойствоXDTO(notification, "documentPublished") Тогда
			
			documentPublished = notification.documentPublished;
			
			Уведомление.Опубликование.Очистить();
			НоваяСтрока = Уведомление.Опубликование.Добавить();
			НоваяСтрока.РегистрационныйНомер = СвойствоXDTOЕслиЕсть(documentPublished.num, "number", "");
			НоваяСтрока.ДатаРегистрации = СвойствоXDTOЕслиЕсть(documentPublished.num, "date", "");
			НоваяСтрока.ПечатныйОрган = СвойствоXDTOЕслиЕсть(documentPublished, "publicationPoint", "");
			
		Иначе
			
			ТекстОшибкиПодробно = СтрШаблон(
				НСтр("ru = 'Во входящем уведомлении ID=%1 по исх.сообщению %2
				|не предусмотренный тип уведомления - указано ""%3""
				|Временный каталог %4'"), 
				ИдентификаторУведомления, ИдентификаторИсходящегоСообщения, ТипУведомленияИзСообщения, ВременныйКаталог);
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка, Документ,
				Текст_ОшибкаЗагрузкиВходящегоУведомления(), ТекстОшибкиПодробно, ДанныеОтвета);
			Возврат;
		КонецЕсли;
		
		Уведомление.Записать();
		
		
		СоздатьИсходящуюКвитанцию(
			ИдентификаторИсходящегоСообщения, Уведомление.Ссылка, Реквизиты.Контрагент, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат;
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Информация,
			Уведомление.Ссылка,
			Текст_ОбъектПолученУспешно(),
			Текст_ОбъектПолученУспешно(),
			ДанныеОтвета);
		
	Исключение
		ОтменитьТранзакцию();
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Временный файл %1. %2'"),
			ВременныйКаталог, ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Документ,
			Текст_ОшибкаЗагрузкиВходящегоУведомления(), ТекстОшибкиПодробно, ДанныеОтвета);
	КонецПопытки;
	
КонецПроцедуры

Функция ПрочитатьDocumentClause(ОбъектXDTO, ДатаУчетаДокумента, ДанныеОтвета)

	Пункт = МЭДОСтруктурыДанных.НовыйПунктДокумента();
	
	Если ОбъектXDTO = Неопределено Тогда
		Возврат Пункт;
	КонецЕсли;
	
	Пункт.НомерПоПорядку = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "localId", 0);
	Пункт.ИдентификаторПункта = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "id", "");
	Пункт.Наименование = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "designation", "");
	Пункт.ТекстПункта = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "text", "");
	Пункт.СрокИсполнения = ЗначениеВДату(
		СвойствоXDTOЕслиЕсть(ОбъектXDTO, "deadline", '00010101'));
	
	principal = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "principal", Неопределено);
	Пункт.Ответственный = ПрочитатьAnyone(principal, ДатаУчетаДокумента, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат Пункт;
	КонецЕсли;
	Пункт.ПолноеПредставление = Пункт.Ответственный.ПолноеПредставление;
	Пункт.Ответственный.ПолноеПредставление = "";// отсюда убираем, чтобы не дублировать, оптимизация хранения.
	Если principal <> Неопределено Тогда
		Пункт.Комментарий = СвойствоXDTOЕслиЕсть(principal, "comment", Неопределено);
		Пункт.ПолноеПредставление = Пункт.ПолноеПредставление
			+ ЗаполненноеЗначениеСтрокой(НСтр("ru = 'Комментарий:'"), Пункт.Комментарий, "");
	КонецЕсли;
	
	Возврат Пункт;

КонецФункции

// Читает из сообщения уведомления объект, описывающий исполнителя - anyone.
// 
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - Объект из дерева сообщения, прочитанного фабрикой XDTO.
//  ДатаУчетаДокумента - Дата - Дата, на которую нужно получить сведения о контрагенте и контактном лице.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
// 
// Возвращаемое значение:
//  см. МЭДОСтруктурыДанных.НовыйОтветственнаяСтруктурнаяЕдиница.
Функция ПрочитатьAnyone(ОбъектXDTO, ДатаУчетаДокумента, ДанныеОтвета)
	
	ОтветственнаяСтруктурнаяЕдиница = МЭДОСтруктурыДанных.НовыйОтветственнаяСтруктурнаяЕдиница();
	
	Если ОбъектXDTO = Неопределено Тогда
		Возврат ОтветственнаяСтруктурнаяЕдиница;
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(ОтветственнаяСтруктурнаяЕдиница.Регион, ПрочитатьQualifiedValue(ОбъектXDTO, "region"));
	
	ЗаполнитьЗначенияСвойств(
		ОтветственнаяСтруктурнаяЕдиница.Юрлицо, ПрочитатьQualifiedValue(ОбъектXDTO, "organization"));
	ЗаполнитьЗначенияСвойств(
		ОтветственнаяСтруктурнаяЕдиница.Персона, ПрочитатьQualifiedValue(ОбъектXDTO, "person"));
	
	Если ЗначениеЗаполнено(ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Идентификатор) Тогда
		// Специально создавать не контрагента не будем, то попытаемся опознать, если уже есть.
		СтруктураКонтрагент = ИнтеграцияСМЭДО.НайтиСоздатьКонтрагента(
			ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Наименование,
			ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Идентификатор,
			ДатаУчетаДокумента,
			Истина,
			ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат ОтветственнаяСтруктурнаяЕдиница;
		КонецЕсли;
		ОтветственнаяСтруктурнаяЕдиница.ЮрлицоСсылка = СтруктураКонтрагент.КонтрагентСсылка;
		
		Если ЗначениеЗаполнено(ОтветственнаяСтруктурнаяЕдиница.Персона.Идентификатор)
			И ЗначениеЗаполнено(ОтветственнаяСтруктурнаяЕдиница.ЮрлицоСсылка) Тогда
			// Если известен контрагент, то привяжем контактное лицо:
			СтруктураКЛ = ИнтеграцияСМЭДО.НайтиСоздатьКонтактноеЛицо(
				СтруктураКонтрагент,
				ОтветственнаяСтруктурнаяЕдиница.Персона.Наименование,
				ОтветственнаяСтруктурнаяЕдиница.Персона.Идентификатор,
				ДатаУчетаДокумента);
			ОтветственнаяСтруктурнаяЕдиница.КонтактноеЛицоСсылка = СтруктураКЛ.КонтактноеЛицоСсылка;
		КонецЕсли;
	КонецЕсли;
	
	// Должности и подразделения контрагентов храним просто в виде строк:
	ЗаполнитьЗначенияСвойств(
		ОтветственнаяСтруктурнаяЕдиница.Подразделение, ПрочитатьQualifiedValue(ОбъектXDTO, "department"));
	ЗаполнитьЗначенияСвойств(
		ОтветственнаяСтруктурнаяЕдиница.Должность, ПрочитатьQualifiedValue(ОбъектXDTO, "post"));
	
	ОтветственнаяСтруктурнаяЕдиница.КонтактнаяИнформацияПредставление
		= СвойствоXDTOЕслиЕсть(ОбъектXDTO, "contactInfo", "");
	
	ОтветственнаяСтруктурнаяЕдиница.ПолноеПредставление
		= ПолучитьПредставлениеОтветственнойСтруктурнойЕдиницы(ОтветственнаяСтруктурнаяЕдиница);
	
	Возврат ОтветственнаяСтруктурнаяЕдиница;
	
КонецФункции

// Читает из сообщения уведомления объект, описывающий сведения о документе - documentReference.
// 
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - Объект из дерева сообщения, прочитанного фабрикой XDTO.
//  ДатаУчетаДокумента - Дата - Дата, на которую нужно получить сведения о контрагенте и контактном лице.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
// 
// Возвращаемое значение:
//  см. МЭДОСтруктурыДанных.НовыйСведенияОДокументе.
Функция ПрочитатьDocumentReference(ОбъектXDTO, ДатаУчетаДокумента, ДанныеОтвета)
	
	СведенияОДокументе = МЭДОСтруктурыДанных.НовыйСведенияОДокументе();
	
	Если ОбъектXDTO = Неопределено Тогда
		Возврат СведенияОДокументе;
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(СведенияОДокументе.Регион, ПрочитатьQualifiedValue(ОбъектXDTO, "region"));
	ЗаполнитьЗначенияСвойств(
		СведенияОДокументе.Юрлицо, ПрочитатьQualifiedValue(ОбъектXDTO, "organization"));
	ЗаполнитьЗначенияСвойств(
		СведенияОДокументе.Персона, ПрочитатьQualifiedValue(ОбъектXDTO, "person"));
	
	Если ЗначениеЗаполнено(СведенияОДокументе.Юрлицо.Идентификатор) Тогда
		// Специально создавать не контрагента не будем, то попытаемся опознать, если уже есть.
		СтруктураКонтрагент = ИнтеграцияСМЭДО.НайтиСоздатьКонтрагента(
			СведенияОДокументе.Юрлицо.Наименование,
			СведенияОДокументе.Юрлицо.Идентификатор,
			ДатаУчетаДокумента,
			Истина,
			ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат СведенияОДокументе;
		КонецЕсли;
		СведенияОДокументе.ЮрлицоСсылка = СтруктураКонтрагент.КонтрагентСсылка;
		
		Если ЗначениеЗаполнено(СведенияОДокументе.Персона.Идентификатор)
			И ЗначениеЗаполнено(СведенияОДокументе.ЮрлицоСсылка) Тогда
			// Если известен контрагент, то привяжем контактное лицо:
			СтруктураКЛ = ИнтеграцияСМЭДО.НайтиСоздатьКонтактноеЛицо(
				СтруктураКонтрагент,
				СведенияОДокументе.Персона.Наименование,
				СведенияОДокументе.Персона.Идентификатор,
				ДатаУчетаДокумента);
			СведенияОДокументе.КонтактноеЛицоСсылка = СтруктураКЛ.КонтактноеЛицоСсылка;
		КонецЕсли;
	КонецЕсли;
	
	// Должности и подразделения контрагентов храним просто в виде строк:
	ЗаполнитьЗначенияСвойств(
		СведенияОДокументе.Подразделение, ПрочитатьQualifiedValue(ОбъектXDTO, "department"));
	ЗаполнитьЗначенияСвойств(
		СведенияОДокументе.Должность, ПрочитатьQualifiedValue(ОбъектXDTO, "post"));
	
	num = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "num", Неопределено);
	Если num <> Неопределено Тогда
		СведенияОДокументе.РегистрационныеДанные.РегистрационныйНомер = СвойствоXDTOЕслиЕсть(num, "number", "");
		СведенияОДокументе.РегистрационныеДанные.ДатаРегистрации =
			ЗначениеВДату(СвойствоXDTOЕслиЕсть(num, "date", '00010101'));
	КонецЕсли;
	
	СведенияОДокументе.Комментарий = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "comment", "");
	
	СведенияОДокументе.ПолноеПредставление = ПолучитьПредставлениеСведенийОДокументе(СведенияОДокументе);
	
	Возврат СведенияОДокументе;
	
КонецФункции

// Обрабатывает входящее сообщение, соответствующее входящей квитанции на исходящий документ или исходящее уведомление.
//
Процедура ОбработатьВходящуюКвитанцию(ВременныйКаталог, communication, ДвоичныеДанныеЭСД, ДанныеОтвета)
	
	ВерсияМЭДОСтрокой = communication.version;
	
	acknowledgment = communication.acknowledgment;
	ИдентификаторКвитанции	= communication.header.uid;
	ИдентификаторСообщения = acknowledgment.uid;
	
	Если Не ЗначениеЗаполнено(ИдентификаторСообщения) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Во входящей квитанции не обнаружен идентификатор сообщения (поле acknowledgment.uid),
			|относительно которого создается квитанция. uid квитанции=%1, временный файл %3'"), 
			ИдентификаторКвитанции,
			ВременныйКаталог);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			СтрШаблон("ru = 'Квитанция %1'", ИдентификаторКвитанции),
			Текст_ОшибкаЗаписиКвитанции(),
			ТекстОшибкиПодробно,
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	// Получим предмет по идентификатору исходящего сообщения, это либо документ, либо уведомление:
	Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Состояния.Документ КАК Предмет,
		|	""ИсходящийДокумент"" КАК ТипПредмета
		|ИЗ
		|	РегистрСведений.СостоянияДокументовМЭДО.СрезПоследних(,
		|		Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Исходящее)) КАК Состояния
		|ГДЕ
		|	ИдентификаторСообщения = &ИдентификаторСообщения
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	Уведомления.Ссылка КАК Предмет,
		|	""ИсходящееУведомление"" КАК ТипПредмета
		|ИЗ
		|	Документ.УведомлениеМЭДО КАК Уведомления
		|ГДЕ
		|	Уведомления.ИдентификаторУведомления = &ИдентификаторСообщения
		|	И Уведомления.Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Исходящее)");
	Запрос.УстановитьПараметр("ИдентификаторСообщения", ИдентификаторСообщения);
	Выборка = Запрос.Выполнить().Выбрать();
	ТипПредмета = Неопределено;
	Предмет = Неопределено;
	Если Выборка.Следующий() Тогда
		Предмет = Выборка.Предмет;
		ТипПредмета = Выборка.ТипПредмета;
	Иначе
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'По входящей квитанции с идентификатором %1 в базе данных не обнаружен
			|предмет с индентификатором %2 - документ или уведомление,
			|временный файл %3'"), 
			ИдентификаторКвитанции,
			ИдентификаторСообщения,
			ВременныйКаталог);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			СтрШаблон("ru = 'Входящая квитанция ID=%1'", ИдентификаторКвитанции),
			Текст_ОшибкаЗаписиКвитанции(),
			ТекстОшибкиПодробно,
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Организация = Неопределено;
	Контрагент = Неопределено;
	Если ТипПредмета = "ИсходящееУведомление" Тогда
		Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Предмет, "Организация, Дата, Контрагент");
		Организация = Реквизиты.Организация;
		Контрагент = Реквизиты.Контрагент;
	ИначеЕсли ТипПредмета = "ИсходящийДокумент" Тогда
		Реквизиты = ИнтеграцияСМЭДО.ПолучитьТребуемыеДанныеИсходящегоДокумента(
			Предмет, "Организация, ДатаУчетаДокумента, Контрагент", ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат;
		КонецЕсли;
		Организация = Реквизиты.Организация;
		Контрагент = Реквизиты.Контрагент;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Контрагент) Тогда
		ТекстОшибкиПодробно = СтрШаблон(НСтр(
			"ru = 'В предмете входящей квитанции %1 ID=%2 по исх.сообщению %3
			|Не удалось найти контрагента.'"),
			Предмет, ИдентификаторКвитанции, ИдентификаторСообщения);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Предмет, 
			Текст_ОшибкаЗаписиКвитанции(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	
	// Квитанцию каждый раз будем заново делать, может напрвляться несколько раз на одну цепочку.
	Квитанция = Документы.КвитанцияМЭДО.СоздатьДокумент();
	Квитанция.Предмет = Предмет;
	Квитанция.Дата = ТекущаяДатаСеанса();
	Квитанция.ИсходящаяДата = ЗначениеВДату(acknowledgment.time);
	Квитанция.Направление = Перечисления.НаправленияСообщенийМЭДО.Входящее;
	Квитанция.Заполнить(Неопределено);
	Квитанция.ИдентификаторКвитанции = ИдентификаторКвитанции;
	Квитанция.ИдентификаторСообщения = ИдентификаторСообщения;
	Квитанция.Контрагент = Контрагент;
	Квитанция.Организация = Организация;
	Квитанция.ДанныеСообщения = Новый ХранилищеЗначения(ДвоичныеДанныеЭСД);
	Квитанция.СообщениеПринято = acknowledgment.accepted;
	Квитанция.ПометкаУдаления = Ложь;
	Если Не Квитанция.СообщениеПринято Тогда
		Если ВерсияМЭДОСтрокой = "2.7.1" Тогда
			Квитанция.КодОшибки = СвойствоXDTOЕслиЕсть(acknowledgment, "errorCode", 0);
		КонецЕсли;
		
		Квитанция.КомментарийОшибки = СвойствоXDTOЕслиЕсть(acknowledgment, "comment", "");
	КонецЕсли;
	
	Попытка
		Квитанция.Записать();
		
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Информация,
			Квитанция.Ссылка,
			Текст_ОбъектПолученУспешно(),
			Текст_ОбъектПолученУспешно(),
			ДанныеОтвета);
	Исключение
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Ошибка при записи квитанции ID=%1: %2, временный файл %3'"), 
			Квитанция.ИдентификаторКвитанции,
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()),
			ВременныйКаталог);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Квитанция.ИдентификаторКвитанции,
			Текст_ОшибкаЗаписиКвитанции(), ТекстОшибкиПодробно, ДанныеОтвета);
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

#Область ИсходящиеКвитанции

// Создает и записывает исходящую квитанцию. 
//
// Параметры:
//   ИдентификаторСообщения - Строка - Идентификатор сообщения, в ответ на которое создается квитанция.
//   Предмет - ОпределяемыйТип.ПредметМЭДО,
//             ДокументСсылка.УведомлениеМЭДО - Предмет исходящей квитанции.
//   Контрагент - ОпределяемыйТип.КонтрагентМЭДО
//   ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
//
Процедура СоздатьИсходящуюКвитанцию(ИдентификаторСообщения, Предмет, Контрагент, ДанныеОтвета)
	
	Если Не ЗначениеЗаполнено(Предмет) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Не определен предмет (документ или уведомление) для исходящей квитанции по сообщению %1'"),
			ИдентификаторСообщения);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Предупреждение, 
			Предмет, 
			НСтр("ru = 'Не определен предмет для квитанции'"),
			ТекстОшибкиПодробно,
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	

	// Сообщение с одним id может приходить несколько раз, каждый раз будем отвечать заново.
	Квитанция = Документы.КвитанцияМЭДО.СоздатьДокумент();
	Квитанция.Направление = Перечисления.НаправленияСообщенийМЭДО.Исходящее;
	Квитанция.Заполнить(Неопределено);
	
	Если ТипЗнч(Предмет) = Тип("ДокументСсылка.УведомлениеМЭДО") Тогда
		Квитанция.Организация = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Предмет, "Организация");
	Иначе
		Реквизиты = ИнтеграцияСМЭДО.ПолучитьТребуемыеДанныеВходящегоДокумента(Предмет, "Организация", ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат;
		КонецЕсли;
		Квитанция.Организация = Реквизиты.Организация;
	КонецЕсли;
	Квитанция.Дата = ТекущаяДатаСеанса() + 10; // Чуть позже, т.к. может записаться в ту же секунду, что и соответствующий документ/уведомление
	Квитанция.ИсходящаяДата = ТекущаяДатаСеанса(); // Для исходящих совпадает.
	Квитанция.ДанныеКонверта			= Неопределено;
	Квитанция.ДанныеСообщения			= Неопределено;
	Квитанция.ИдентификаторКвитанции	= "" + ИнтеграцияСМЭДО.СсылкаНовогоОбъекта(Квитанция).УникальныйИдентификатор();
	Квитанция.ИдентификаторСообщения	= ИдентификаторСообщения;
	Квитанция.Отправлена				= Ложь;
	Квитанция.Контрагент				= Контрагент;
	Квитанция.Предмет					= Предмет;
	Квитанция.ПометкаУдаления			= Ложь;
	Квитанция.Записать();
	
КонецПроцедуры

// Функция - Возвращает данные неотправленных ранее исходящих квитанций для отправки по МЭДО.
//
// Параметры:
//  Настройки - Структура - поля:
//   * Организация - ОпределяемыйТип.Организация
//   * КаталогОтправки - Строка
//   * РазмерПорции - Число
//
// Возвращаемое значение:
//   Соответствие из КлючИЗначение
//   * Ключ - ДокументСсылка.КвитанцияМЭДО - Ссылка на квитанцию.
//   * Значение - Структура - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящейКвитанцииДляОтправки.
//
Функция ДанныеИсходящихКвитанцийДляОтправки(Настройки)
	
	УстановитьПривилегированныйРежим(Истина);
	
	ДанныеКвитанций = Новый Соответствие();
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 9999
		|	Квитанции.Ссылка КАК Квитанция,
		|	Квитанции.Дата КАК Дата,
		|	Квитанции.Предмет КАК Предмет,
		|	Квитанции.ИдентификаторСообщения КАК ИдентификаторСообщения,
		|	Квитанции.ИдентификаторКвитанции КАК ИдентификаторКвитанции,
		|	Квитанции.Контрагент КАК Контрагент,
		|	ВЫБОР
		|		КОГДА НЕ НастройкиКонтрагентовМЭДО.ВерсияФорматаМЭДО IS NULL
		|			И НастройкиКонтрагентовМЭДО.ВерсияФорматаМЭДО <> ЗНАЧЕНИЕ(Перечисление.ВерсииФорматаМЭДО.ПустаяСсылка)
		|			ТОГДА НастройкиКонтрагентовМЭДО.ВерсияФорматаМЭДО
		|		КОГДА НЕ ДанныеМЭДО.ВерсияМЭДО IS NULL
		|			И ДанныеМЭДО.ВерсияМЭДО <> ЗНАЧЕНИЕ(Перечисление.ВерсииФорматаМЭДО.ПустаяСсылка)
		|			ТОГДА ДанныеМЭДО.ВерсияМЭДО
		|		ИНАЧЕ &ПоследняяВерсия
		|	КОНЕЦ КАК ВерсияМЭДО,
		|	НастройкиКонтрагентовМЭДО.АдресМЭДО КАК АдресМЭДОКонтрагента
		|ИЗ
		|	Документ.КвитанцияМЭДО КАК Квитанции
		|		ЛЕВОЕ СОЕДИНЕНИЕ Документ.ДанныеДокументаМЭДО КАК ДанныеМЭДО
		|		ПО Квитанции.Предмет = ДанныеМЭДО.Документ
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.НастройкиКонтрагентовМЭДО КАК НастройкиКонтрагентовМЭДО
		|		ПО НастройкиКонтрагентовМЭДО.Контрагент = Квитанции.Контрагент
		|ГДЕ
		|	Квитанции.Организация = &Организация
		|	И НЕ Квитанции.ПометкаУдаления
		|	И НЕ Квитанции.Отправлена
		|	И Квитанции.Направление = ЗНАЧЕНИЕ(Перечисление.НаправленияСообщенийМЭДО.Исходящее)");
	Запрос.УстановитьПараметр("Организация", Настройки.Организация);
	Запрос.УстановитьПараметр("ПоследняяВерсия", Перечисления.ВерсииФорматаМЭДО.ПоследняяВерсия());
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "9999", "" + Настройки.РазмерПорции);
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Данные = МЭДОСтруктурыДанных.НовыйДанныеИсходящейКвитанцииДляОтправки();
		ЗаполнитьЗначенияСвойств(
			Данные, Выборка, 
			"Квитанция, ВерсияМЭДО, Дата, Предмет, ИдентификаторСообщения, ИдентификаторКвитанции");
		
		ДанныеОтвета = МЭДОСтруктурыДанных.НовыйОтвет();
		
		Реквизиты = Неопределено;
		ДатаУчета = '00010101';
		Если ТипЗнч(Данные.Предмет) = Тип("ДокументСсылка.УведомлениеМЭДО") Тогда
			Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Данные.Предмет, "Организация, Контрагент, Дата");
			ДатаУчета = Реквизиты.Дата;
		Иначе
			Реквизиты = ИнтеграцияСМЭДО.ПолучитьТребуемыеДанныеВходящегоДокумента(
				Данные.Предмет, "Организация, Контрагент, ДатаУчетаДокумента", ДанныеОтвета);
			ДатаУчета = Реквизиты.ДатаУчетаДокумента;
		КонецЕсли;
		
		Если Не ДанныеОтвета.Успех Тогда
			Возврат ДанныеКвитанций;
		КонецЕсли;
		СтруктураОрганизация = ПолучитьПоляОрганизации(
			Реквизиты.Организация, ДатаУчета, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат ДанныеКвитанций;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(Данные.Организация, СтруктураОрганизация);
		СтруктураКонтрагент = ПолучитьПоляКонтрагента(
			Реквизиты.Контрагент, ДатаУчета, Истина, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат ДанныеКвитанций;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(Данные.Контрагент, СтруктураКонтрагент);
		
		ДанныеКвитанций[Выборка.Квитанция] = Данные;
	КонецЦикла;
	
	Возврат ДанныеКвитанций;
	
КонецФункции

// Процедура - Создает и записывает сообщение по исходящей квитанции.
// 
// Параметры:
//  Путь - Строка - путь к каталогу для помещения сообщения.
//  Квитанция - ДокументСсылка.КвитанцияМЭДО - Исходящая квитанция для отправки.
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящейКвитанцииДляОтправки.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ЗаписатьСообщениеПоИсходящейКвитанции(Путь, Квитанция, Данные, ДанныеОтвета)
	
	УстановитьПривилегированныйРежим(Истина);
	
	ВерсияМЭДО = Данные.ВерсияМЭДО;
	Если Не ЗначениеЗаполнено(ВерсияМЭДО) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'У получателя квитанции %1 по документу %2 не указана версия МЭДО
			|(можно указать либо для контрагента, либо для самого документа)'"),
			Данные.Контрагент.Наименование);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Данные.Предмет,
			Текст_ОшибкаВКонтрагенте(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(Данные.Контрагент.Идентификатор) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'У получателя квитанции %1 не указан идентификатор МЭДО'"),
			Данные.Контрагент.Наименование);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Данные.Предмет,
			Текст_ОшибкаВКонтрагенте(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(Данные.Контрагент.АдресМЭДО) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'У получателя квитанции %1 не указан адрес МЭДО'"),
			Данные.Контрагент.Наименование);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Данные.Предмет,
			Текст_ОшибкаВКонтрагенте(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Попытка
		
		ПодкаталогСообщения = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(
			ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(Путь) + Данные.ИдентификаторКвитанции);
		СоздатьКаталог(ПодкаталогСообщения);
		Данные.ПодкаталогСообщения = ПодкаталогСообщения;
		
		ПолноеИмяФайлаКонверта = ПодкаталогСообщения + "envelope.ini";
		
		Адресаты = Новый Массив();
		НомерАдресата = 0;
		Адресат = СтрШаблон("%1=%2", Формат(НомерАдресата, "ЧН=0; ЧГ=0"), Данные.Контрагент.АдресМЭДО);
		Адресаты.Добавить(Адресат);
		НомерАдресата = НомерАдресата + 1;
		АдресатыСтрокой = СтрСоединить(Адресаты, Символы.ПС);
		
		Конверт = Новый ТекстовыйДокумент();
		Конверт.УстановитьТекст(СтрШаблон(
			"[ПИСЬМО КП ПС СЗИ]
			|АВТООТПРАВКА=1
			|[АДРЕСАТЫ]
			|%1
			|[ФАЙЛЫ]
			|0=acknowledgment.xml",
			АдресатыСтрокой));
		Конверт.Записать(ПолноеИмяФайлаКонверта, "windows-1251");
		
		ПолноеИмяФайлаСообщения = ПодкаталогСообщения + "acknowledgment.xml";
		Пакет = ПакетXDTOСообщенияПоВерсииМЭДО(ВерсияМЭДО);
		ТипCommunication = Пакет.КорневыеСвойства.Получить("communication").Тип;
		communication = ФабрикаXDTO.Создать(ТипCommunication);
		communication.version = "" + ВерсияМЭДО;
		communication.header = ФабрикаXDTO.Создать(ТипCommunication.Свойства.Получить("header").Тип);
		communication.header.type = "Квитанция";
		communication.header.uid = НРег(Данные.ИдентификаторКвитанции);
		communication.header.created = 
			?(ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271, ДатаФорматаDateTimeZone(Данные.Дата), Данные.Дата);
		communication.header.source = НовыйОбъектСообщения("communicationPartner", ВерсияМЭДО);
		communication.header.source.uid = НРег(Данные.Контрагент.Идентификатор);
		communication.header.source.organization = Данные.Контрагент.Наименование;
		
		communication.acknowledgment = ФабрикаXDTO.Создать(
			ТипCommunication.Свойства.Получить("acknowledgment").Тип);
		communication.acknowledgment.uid = НРег(Данные.ИдентификаторСообщения);
		communication.acknowledgment.time = 
			?(ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271, ДатаФорматаDateTimeZone(Данные.Дата), Данные.Дата);
		communication.acknowledgment.accepted = Истина;
		
		destination = НовыйОбъектСообщения("communicationPartner", ВерсияМЭДО);
		destination.uid = Нрег(Данные.Контрагент.Идентификатор);
		destination.organization = Данные.Контрагент.Наименование;
		deliveryDestination = НовыйОбъектСообщения("deliveryDestination", ВерсияМЭДО);
		deliveryDestination.destination = destination;
		communication.deliveryIndex = ФабрикаXDTO.Создать(ТипCommunication.Свойства.Получить("deliveryIndex").Тип);
		communication.deliveryIndex.destination.Добавить(deliveryDestination);
		
		
		ЗаписьXML = Новый ЗаписьXML();
		ЗаписьXML.ОткрытьФайл(ПолноеИмяФайлаСообщения, "UTF-8");
		ЗаписьXML.ЗаписатьОбъявлениеXML();
		ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, communication, "communication",,, НазначениеТипаXML.Неявное);
		ЗаписьXML.Закрыть();
		
		КвитанцияОбъект = Квитанция.ПолучитьОбъект();
		КвитанцияОбъект.Отправлена = Истина;
		ДвоичныеДанныеКонверта = Новый ДвоичныеДанные(ПолноеИмяФайлаКонверта);
		КвитанцияОбъект.ДанныеКонверта = Новый ХранилищеЗначения(ДвоичныеДанныеКонверта);
		ДвоичныеДанныеСообщения = Новый ДвоичныеДанные(ПолноеИмяФайлаСообщения);
		КвитанцияОбъект.ДанныеСообщения = Новый ХранилищеЗначения(ДвоичныеДанныеСообщения);
		КвитанцияОбъект.Записать();
		
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Информация,
			Квитанция,
			Текст_ОбъектОтправленУспешно(),
			Текст_ОбъектОтправленУспешно(),
			ДанныеОтвета);
		
	Исключение
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			Квитанция,
			НСтр("ru = 'Ошибка создания исходящей квитанции'"),
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()),
			ДанныеОтвета);
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

#Область ИсходящиеДокументы

// Процедура - Создает и записывает паспорт контейнера исходящего документа.
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоДокументаДляОтправки.
//  ПолноеИмяФайла - Строка - Путь к xml-файлу - паспорту контейнера. 
//                            На выходе по этому пути будет создан сам файл (passport.xml)
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура СоздатьПаспортКонтейнераИсходящегоДокумента(Данные, ПолноеИмяФайла, ДанныеОтвета)
	
	ВерсияМЭДО = Данные.ВерсияМЭДО;
	
	Пакет = ПакетXDTOКонтейнераПоВерсииМЭДО(ВерсияМЭДО);
	ТипContainer = Пакет.КорневыеСвойства.Получить("container").Тип;
	container = ФабрикаXDTO.Создать(ТипContainer);
	
	container.version = ВерсияПаспортаПоВерсииМЭДО(ВерсияМЭДО);
	container.uid = Данные.ИдентификаторДокумента;
	
	// Вид документа МЭДО
	container.requisites = ФабрикаXDTO.Создать(ТипContainer.Свойства.Получить("requisites").Тип);
	container.requisites.documentKind = НовыйОбъектКонтейнера("qualifiedValue", ВерсияМЭДО);
	container.requisites.documentKind.id = "" + Данные.ВидДокумента.Идентификатор;
	container.requisites.documentKind.__content = Данные.ВидДокумента.Наименование;
	
	
	// Место составления:
	Если ЗначениеЗаполнено(Данные.МестоСоставления.Наименование) Тогда
		container.requisites.documentPlace = НовыйОбъектКонтейнера("qualifiedValue", ВерсияМЭДО);
		container.requisites.documentPlace.id = Данные.МестоСоставления.Идентификатор;
		container.requisites.documentPlace.__content = Данные.МестоСоставления.Наименование;
	Иначе
		// Место составления для 2.7.1 - обязательное, для 2.7 - не обязательное.
		Если Данные.ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				Данные.Документ,
				Текст_ОшибкаВДокументе(),
				НСтр("ru = 'В документе не указано место составления, это обязательное поле.'"),
				ДанныеОтвета);
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	
	// Гриф доступа:
	Если ЗначениеЗаполнено(Данные.ГрифДоступа.Наименование) Тогда
		container.requisites.classification = НовыйОбъектКонтейнера("qualifiedValue", ВерсияМЭДО);
		container.requisites.classification.__content = Данные.ГрифДоступа.Наименование;
		Если ЗначениеЗаполнено(Данные.ГрифДоступа.Идентификатор) Тогда
			container.requisites.classification.id = Данные.ГрифДоступа.Идентификатор;
		Иначе
			Если ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
				ТекстОшибкиПодробно =
					НСтр("ru = 'Для отправки документа по формату версии МЭДО 2.7.1 должен быть задан гриф доступа и в документе и в настройках'");
				ЗаписьВЖурналСобытий(
					Перечисления.УровниСобытийМЭДО.Ошибка,
					Данные.Документ,
					Текст_ОшибкаВДокументе(),
					ТекстОшибкиПодробно,
					ДанныеОтвета);
				Возврат;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	
	Заголовок = СтрЗаменить(Данные.Заголовок, """", "");
	Заголовок = СтрЗаменить(Заголовок, "'", "");
	container.requisites.annotation = Заголовок;
	
	
	Если Данные.СвязанныеДокументы.Количество() > 0 Тогда
		container.requisites.links = НовыйОбъектКонтейнера("qualifiedValue", ВерсияМЭДО);
		ТипRequisites = ТипContainer.Свойства.Получить("requisites").Тип;
		container.requisites.links = ФабрикаXDTO.Создать(ТипRequisites.Свойства.Получить("links").Тип);
		
		Для Каждого СвязанныйДокумент Из Данные.СвязанныеДокументы Цикл 
			linkedDocument = НовыйОбъектКонтейнера("linkedDocument", ВерсияМЭДО);
			container.requisites.links.link.Добавить(linkedDocument);
		КонецЦикла;
	КонецЕсли;
	
	
	container.document = ФабрикаXDTO.Создать(ТипContainer.Свойства.Получить("document").Тип);
	container.document.localName = Данные.Файл.ЛокальноеИмя;
	container.document.description = Данные.Содержание;
	container.document.pagesQuantity = Данные.КоличествоЛистов;
	
	
	// Отправитель:
	container.authors = ФабрикаXDTO.Создать(ТипContainer.Свойства.Получить("authors").Тип);
	issuer = НовыйОбъектКонтейнера("issuer", ВерсияМЭДО);
	issuer.organization = НовыйОбъектКонтейнера("organization", ВерсияМЭДО);
	issuer.organization.id = Данные.Отправитель.Организация.Идентификатор;
	issuer.organization.title = Данные.Отправитель.Организация.Наименование;
	issuer.registration = НовыйОбъектКонтейнера("registration", ВерсияМЭДО);
	issuer.registration.number = Данные.Отправитель.РегистрационныйНомер;
	Если ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
		issuer.registration.date = Формат(Данные.Отправитель.ДатаРегистрации, "ДФ=yyyy-MM-dd;");
	Иначе
		issuer.registration.date = Данные.Отправитель.ДатаРегистрации;
	КонецЕсли;
	
	issuer.registration.registrationStamp = НовыйОбъектКонтейнера("stamp", ВерсияМЭДО);
	РегистрационныйШтамп = Данные.Отправитель.РегистрационныйШтамп;
	issuer.registration.registrationStamp.localName = РегистрационныйШтамп.Файл.ЛокальноеИмя;
	position = НовыйОбъектКонтейнера("position", ВерсияМЭДО);
	position.page = РегистрационныйШтамп.Положение.Страница;
	position.topLeft = НовыйОбъектКонтейнера("coordinate", ВерсияМЭДО);
	position.topLeft.x = РегистрационныйШтамп.Положение.Слева;
	position.topLeft.y = РегистрационныйШтамп.Положение.Сверху;
	position.dimension = НовыйОбъектКонтейнера("dimension", ВерсияМЭДО);
	position.dimension.w = РегистрационныйШтамп.Положение.Ширина;
	position.dimension.h = РегистрационныйШтамп.Положение.Высота;
	issuer.registration.registrationStamp.position = position;
	
	ТипSign = issuer.Свойства().Получить("sign").Тип;
	Для Каждого Подпись Из Данные.Отправитель.Подписи Цикл
		sign = ФабрикаXDTO.Создать(ТипSign);
		sign.person = НовыйОбъектКонтейнера("signer", ВерсияМЭДО);
		sign.person.name = Подпись.Подписал.ФИО;
		ПрисвоитьЗаполненное(sign.person.post, Подпись.Подписал.Должность.Наименование);
		sign.documentSignature = НовыйОбъектКонтейнера("signatureInfo", ВерсияМЭДО);
		sign.documentSignature.localname = Подпись.Файл.ЛокальноеИмя;
		sign.documentSignature.signatureStamp = НовыйОбъектКонтейнера("stamp", ВерсияМЭДО);
		position = НовыйОбъектКонтейнера("position", ВерсияМЭДО);
		position.page = Подпись.ОтметкаЭП.Положение.Страница;
		position.topLeft = НовыйОбъектКонтейнера("coordinate", ВерсияМЭДО);
		position.topLeft.x = Подпись.ОтметкаЭП.Положение.Слева;
		position.topLeft.y = Подпись.ОтметкаЭП.Положение.Сверху;
		position.dimension = НовыйОбъектКонтейнера("dimension", ВерсияМЭДО);
		position.dimension.w = Подпись.ОтметкаЭП.Положение.Ширина;
		position.dimension.h = Подпись.ОтметкаЭП.Положение.Высота;
		sign.documentSignature.signatureStamp.position = position;
		sign.documentSignature.signatureStamp.localName = Подпись.ОтметкаЭП.Файл.ЛокальноеИмя;
		
		issuer.sign.Добавить(sign);
	КонецЦикла;
	// Исполнитель:
	Если ЗначениеЗаполнено(Данные.Отправитель.Исполнитель.ФИО) Тогда
		issuer.executor = НовыйОбъектКонтейнера("executor", ВерсияМЭДО);
		issuer.executor.name = Данные.Отправитель.Исполнитель.ФИО;
		ПрисвоитьЗаполненное(issuer.executor.post, Данные.Отправитель.Исполнитель.Должность.Наименование);
		ПрисвоитьЗаполненное(issuer.executor.phone, Данные.Отправитель.Исполнитель.Телефон);
	Иначе
		Если Данные.ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				Данные.Документ,
				Текст_ОшибкаВДокументе(),
				НСтр("ru = 'В документе не указан исполнитель, для формата 2.7.1 это обязательное поле.'"),
				ДанныеОтвета);
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	container.authors.author.Добавить(issuer);
	
	
	// Получатели:
	ТипAddressees = ТипContainer.Свойства.Получить("addressees").Тип;
	container.addressees = ФабрикаXDTO.Создать(ТипAddressees);
	ТипAddressee = ТипAddressees.Свойства.Получить("addressee").Тип;
	Для Каждого Получатель Из Данные.Получатели Цикл
		addressee = ФабрикаXDTO.Создать(ТипAddressee);
		addressee.organization = НовыйОбъектКонтейнера("organization", ВерсияМЭДО);
		addressee.organization.id = Получатель.Контрагент.Идентификатор;
		addressee.organization.title = Получатель.Контрагент.Наименование;
		Если ЗначениеЗаполнено(Получатель.КонтактноеЛицо.ФИО) Тогда
			person = НовыйОбъектКонтейнера("person", ВерсияМЭДО);
			person.name		= Получатель.КонтактноеЛицо.ФИО;
			ПрисвоитьЗаполненное(person.post, Получатель.КонтактноеЛицо.Должность.Наименование);
			ПрисвоитьЗаполненное(person.phone, Получатель.КонтактноеЛицо.Телефон);
			ПрисвоитьЗаполненное(person.email, Получатель.КонтактноеЛицо.ЭлектроннаяПочта);
			addressee.person.Добавить(person);
		КонецЕсли;
		container.addressees.addressee.Добавить(addressee);
	КонецЦикла;
	
	
	Если Данные.ПодписьКонтейнера.ДвоичныеДанные <> Неопределено Тогда
		container.containerSignature = ФабрикаXDTO.Создать(ТипContainer.Свойства.Получить("containerSignature").Тип);
		container.containerSignature.localName = "signature.p7s";
	КонецЕсли;
	
	
	// Приложения:
	Если Данные.Приложения.Количество() Тогда
		ТипAttachments = ТипContainer.Свойства.Получить("attachments").Тип;
		container.attachments = ФабрикаXDTO.Создать(ТипAttachments);
		ТипAttachment = ТипAttachments.Свойства.Получить("attachment").Тип;		
		Для Каждого Приложение Из Данные.Приложения Цикл 		
			attachment = ФабрикаXDTO.Создать(ТипAttachment);
			attachment.localName = Приложение.ЛокальноеИмя;
			attachment.order = container.attachments.attachment.Количество();
			container.attachments.attachment.Добавить(attachment);
		КонецЦикла;
	КонецЕсли;
	
	
	ЗаписьXML = Новый ЗаписьXML();
	ЗаписьXML.ОткрытьФайл(ПолноеИмяФайла, "UTF-8");
	ЗаписьXML.ЗаписатьОбъявлениеXML();
	ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, container, "container",,, НазначениеТипаXML.Неявное);
	ЗаписьXML.Закрыть();
	
КонецПроцедуры

// Функция - Возвращает двоичные данные zip-архива - контейнера исходящего документа
//
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоДокументаДляОтправки.
// 
// Возвращаемое значение:
//  ДвоичныеДанные - 
//
Функция ПолучитьДвоичныеДанныеКонтейнераИсходящегоДокумента(Данные)
	
	ФайлыКУдалению = Новый Массив;
	ЗаписьZip = Новый ЗаписьZipФайла();
	
	ИмяФайла = Данные.ВременныйКаталог + "passport.xml";
	ЗаписьZip.Добавить(ИмяФайла);
	ФайлыКУдалению.Добавить(ИмяФайла);
	
	ИмяФайла = Данные.ВременныйКаталог + Данные.Файл.ЛокальноеИмя;
	ЗаписьZip.Добавить(ИмяФайла);
	ФайлыКУдалению.Добавить(ИмяФайла);
	
	ИмяФайла = Данные.ВременныйКаталог + Данные.Отправитель.РегистрационныйШтамп.Файл.ЛокальноеИмя;
	ЗаписьZip.Добавить(ИмяФайла);
	ФайлыКУдалению.Добавить(ИмяФайла);
	
	Для Каждого Подпись Из Данные.Отправитель.Подписи Цикл
		
		ИмяФайла = Данные.ВременныйКаталог + Подпись.Файл.ЛокальноеИмя;
		ЗаписьZip.Добавить(ИмяФайла);
		ФайлыКУдалению.Добавить(ИмяФайла);
		
		ИмяФайла = Данные.ВременныйКаталог + Подпись.ОтметкаЭП.Файл.ЛокальноеИмя;
		ЗаписьZip.Добавить(ИмяФайла);
		ФайлыКУдалению.Добавить(ИмяФайла);
		
	КонецЦикла;
	
	// Подписывание при отправке может быть отключено.
	Если Данные.ПодписьКонтейнера.ДвоичныеДанные <> Неопределено Тогда
		ИмяФайла = Данные.ВременныйКаталог + Данные.ПодписьКонтейнера.ЛокальноеИмя;
		ЗаписьZip.Добавить(ИмяФайла);
		ФайлыКУдалению.Добавить(ИмяФайла);
	КонецЕсли;
	
	
	Для Каждого Приложение Из Данные.Приложения Цикл
		ИмяФайла = Данные.ВременныйКаталог + Приложение.ЛокальноеИмя;
		ЗаписьZip.Добавить(ИмяФайла);
		ФайлыКУдалению.Добавить(ИмяФайла);
	КонецЦикла;
	
	
	ИмяФайла = Данные.ВременныйКаталог + Данные.СодержимоеКонтейнера.ЛокальноеИмя; // не архивируем
	ФайлыКУдалению.Добавить(ИмяФайла);
	
	ДвоичныеДанныеКонтейнера = ЗаписьZip.ПолучитьДвоичныеДанные();
	
	Для Каждого ФайлКУдалению Из ФайлыКУдалению Цикл
		УдалитьФайлы(ФайлКУдалению);
	КонецЦикла;
	
	Возврат ДвоичныеДанныеКонтейнера;
	
КонецФункции

// Вспомогательный документ "Данные документа МЭДО" для хранения дополнительных данных МЭДО,
// отсутствующих в основном документе
// 
// Параметры:
//  Документ - ОпределяемыйТип.ПредметМЭДО
//  ДанныеДокумента - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоДокументаДляОтправки.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ЗаписатьДанныеИсходящегоДокументаМЭДО(Документ, ДанныеДокумента, ДанныеОтвета)
	
	ДанныеОбъект = Документы.ДанныеДокументаМЭДО.ПолучитьОбъектДанныхДокумента(Документ, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат;
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(
		ДанныеОбъект, ДанныеДокумента,
		"ВерсияМЭДО, ИдентификаторДокумента, ИдентификаторСообщения, Отправлен, ГотовКОтправке");
	ДанныеОбъект.ВидДокумента = ДанныеДокумента.ВидДокументаСсылка;
	ДанныеОбъект.ГлавныйФайл = ДанныеДокумента.ГлавныйФайлСсылка;
	ДанныеОбъект.ГрифДоступа = ДанныеДокумента.ГрифДоступаСсылка;
	ДанныеОбъект.МестоСоставления = ДанныеДокумента.МестоСоставленияСсылка;
	ДанныеОбъект.Направление = Перечисления.НаправленияСообщенийМЭДО.Исходящее;
	ДанныеОбъект.Организация = ДанныеДокумента.Отправитель.Организация.ОрганизацияСсылка;
	Документы.ДанныеДокументаМЭДО.ЗаписатьОбъектДанныхДокумента(ДанныеОбъект, ДанныеОтвета);
	
КонецПроцедуры

#КонецОбласти

#Область ИсходящиеУведомления

// Функция - Возвращает данные уведомления для отправки по МЭДО.
// 
// Параметры:
//  УведомлениеСсылка - ДокументСсылка.УведомлениеМЭДО - Ссылка на исходящее уведомление.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
// 
// Возвращаемое значение:
//  см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
Функция ДанныеИсходящегоУведомленияДляОтправки(УведомлениеСсылка, ДанныеОтвета)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Данные = МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки();
	
	РеквизитыУведомления = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
		УведомлениеСсылка,
		"Документ, Комментарий, ТипУведомления, ВерсияМЭДО, Дата, ПостановкаНаКонтроль_КонтрольныеПунктыДокумента");
	СтруктураСостояния = РегистрыСведений.СостоянияДокументовМЭДО.ПолучитьСостояниеДокумента(
		РеквизитыУведомления.Документ,
		Перечисления.СостоянияДокументовМЭДО.ДокументПолучен,
		"ИдентификаторДокумента, ИдентификаторСообщения",
		РеквизитыУведомления.Дата);
	Если Не ЗначениеЗаполнено(СтруктураСостояния.ИдентификаторДокумента) Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВРегистреСостояний(),
			НСтр("ru = 'Для отправки уведомления нет записи по нужному документу в регистре ""Состояния документов МЭДО"".'"),
			ДанныеОтвета);
		Возврат Данные;
	КонецЕсли;
	
	Данные.ИдентификаторВходящегоСообщения = НРег(СтруктураСостояния.ИдентификаторСообщения);
	
	
	КонтрольныеПунктыДокумента = РеквизитыУведомления.ПостановкаНаКонтроль_КонтрольныеПунктыДокумента.Выгрузить();
	
	Данные.ИдентификаторДокумента = НРег(СтруктураСостояния.ИдентификаторДокумента);
	Данные.УведомлениеСсылка = УведомлениеСсылка;
	Данные.Документ = РеквизитыУведомления.Документ;
	Данные.Комментарий = РеквизитыУведомления.Комментарий;
	Данные.Состояние = Перечисления.СостоянияДокументовМЭДО.ОтправленоУведомление;
	Данные.Дата = РеквизитыУведомления.Дата;
	Данные.ТипУведомленияСсылка = РеквизитыУведомления.ТипУведомления;
	Данные.ТипУведомления = Перечисления.ТипыУведомленийМЭДО.СтроковоеЗначениеПоЗначению(Данные.ТипУведомленияСсылка);
	
	// Часть данных уведомления зависит от его типа:
	Если Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОПостановкеНаКонтроль Тогда
		
		ИсходящееУведомление_ЗаполнитьПостановкуНаКонтроль(
			Данные, УведомлениеСсылка, КонтрольныеПунктыДокумента, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		
	ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОРегистрации Тогда
		
		Реквизиты = ИнтеграцияСМЭДО.ПолучитьТребуемыеДанныеВходящегоДокумента(
			Данные.Документ, "РегистрационныйНомер, ДатаРегистрации", ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(Данные.Регистрация, Реквизиты, "РегистрационныйНомер, ДатаРегистрации");
		
	ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОбОтказеВРегистрации Тогда
		
		ИсходящееУведомление_ЗаполнитьОтказВРегистрации(Данные, УведомлениеСсылка, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		
	ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОПринятииКИсполнению Тогда 
		
		ИсходящееУведомление_ЗаполнитьПринятиеКИсполнению(Данные, УведомлениеСсылка, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		
	ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОПодготовкеДоклада Тогда
		
		ИсходящееУведомление_ЗаполнитьПодготовкуДоклада(Данные, УведомлениеСсылка, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		
	ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОНаправленииДоклада Тогда
		
		ИсходящееУведомление_ЗаполнитьНаправлениеДоклада(Данные, УведомлениеСсылка, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		
	ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОХодеИсполнения Тогда
		
		ИсходящееУведомление_ЗаполнитьХодИсполнения(Данные, УведомлениеСсылка, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		
	ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОбОпубликовании Тогда
		
		ИсходящееУведомление_ЗаполнитьОпубликование(Данные, УведомлениеСсылка, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		
	Иначе
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Невозможно отправить %1 типа ""%2"" для документа %3
			|Возможно, некорректный тип уведомления.'"),
			УведомлениеСсылка, Данные.ТипУведомленияСсылка, Данные.Документ);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Данные.Документ,
			Текст_ОшибкаВУведомлении(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат Данные;
	КонецЕсли;
	
	
	// Общие поля для всех видов уведомлений:
	Реквизиты = ИнтеграцияСМЭДО.ПолучитьТребуемыеДанныеВходящегоДокумента(
		Данные.Документ, 
		"Организация, Контрагент, ДатаУчетаДокумента, ИсходящийНомер, ИсходящаяДата, ИсходящийПодписал, Комментарий",
		ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат Данные;
	КонецЕсли;
	СтруктураОрганизация = ПолучитьПоляОрганизации(
		Реквизиты.Организация, Реквизиты.ДатаУчетаДокумента, ДанныеОтвета);
	Если Не ДанныеОтвета.Успех Тогда
		Возврат Данные;
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(Данные.Организация, СтруктураОрганизация);
	
	// Сведения о входящем документе, относительно которого создано уведомление:
	ЗаполнитьСведенияОДокументе(
		Данные.СведенияОДокументе,
		Реквизиты.Контрагент,
		Реквизиты.ИсходящийПодписал,
		Реквизиты.ДатаУчетаДокумента,
		Реквизиты.ИсходящаяДата,
		Реквизиты.ИсходящийНомер,
		Реквизиты.Комментарий,
		ДанныеОтвета);
	
	Данные.Контрагент = ПолучитьПоляКонтрагента(
		Реквизиты.Контрагент, Реквизиты.ДатаУчетаДокумента, Истина, ДанныеОтвета);
	
	// Данные.ПунктДокумента - если нужен.
	// ТЧ ПостановкаНаКонтроль_КонтрольныеПунктыДокумента используется не только для уведомлений типа "Постановка
	// на контроль", но и для указания пункта документа к которому относится уведомление, при любом типе уведомления.
	Если КонтрольныеПунктыДокумента <> Неопределено И КонтрольныеПунктыДокумента.Количество() > 0 Тогда
		СтрокаТЧ = КонтрольныеПунктыДокумента[0];
		ЗаполнитьЗначенияСвойств(
			Данные.ПунктДокумента, СтрокаТЧ,
			"НомерПоПорядку, ИдентификаторПункта, Наименование, ТекстПункта, СрокИсполнения, Комментарий");
		ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
			Данные.ПунктДокумента.Ответственный, СтрокаТЧ.Юрлицо, СтрокаТЧ.Ответственный, Реквизиты.ДатаУчетаДокумента, ДанныеОтвета);
		Данные.ПунктДокумента.ПолноеПредставление = СтрокаТЧ.ОтветственныйПредставление;
	КонецЕсли;
	
	
	// ВерсияМЭДО - если не указана у контрагента, то может быть указана в уведомлении, 
	// потом напрямую в документе, если и там нет,
	// то только тогда берется последняя версия:
	Данные.ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.ПоследняяВерсия();// ниже может быть переопределена.
	Если ЗначениеЗаполнено(РеквизитыУведомления.ВерсияМЭДО) Тогда
		Данные.ВерсияМЭДО = РеквизитыУведомления.ВерсияМЭДО;
	КонецЕсли;
	Если ЗначениеЗаполнено(Данные.Контрагент.ВерсияМЭДО) Тогда
		Данные.ВерсияМЭДО = Данные.Контрагент.ВерсияМЭДО;
	Иначе
		ДанныеДокумента = Документы.ДанныеДокументаМЭДО.ПолучитьДанныеДокументаМЭДО(
			Данные.Документ, "ВерсияМЭДО", ДанныеОтвета); 
		Если Не ДанныеОтвета.Успех Тогда
			Возврат Данные;
		КонецЕсли;
		Если ЗначениеЗаполнено(ДанныеДокумента.ВерсияМЭДО) Тогда
			Данные.ВерсияМЭДО = ДанныеДокумента.ВерсияМЭДО;
		КонецЕсли;
	КонецЕсли;
	
	Если Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОПостановкеНаКонтроль И
		(Данные.ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия25 
		Или Данные.ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия27) Тогда
		
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Запись отменена. Для версии МЭДО %1 нельзя создавать уведомления типа ""%2""!'"),
			Данные.ВерсияМЭДО, Данные.ТипУведомленияСсылка );
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВУведомлении(),
			ТекстОшибкиПодробно,
			ДанныеОтвета);
		Возврат Данные;
	КонецЕсли;
	
	
	Возврат Данные;
	
КонецФункции

// Процедура - Создает и записывает сообщение по исходящему уведомлению.
// 
// Параметры:
//  Настройки - Структура - поля:
//   * Организация - ОпределяемыйТип.Организация
//   * КаталогОтправки - Строка
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ЗаписатьСообщениеПоИсходящемуУведомлению(Настройки, Данные, ДанныеОтвета)
	
	ВерсияМЭДО = Данные.ВерсияМЭДО;
	
	Если Не ЗначениеЗаполнено(ВерсияМЭДО) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'У получателя уведомления %1 по документу %2 не указана версия МЭДО
			|(можно указать либо для контрагента, либо для самого документа)'"),
			Данные.Контрагент.Наименование);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Данные.Документ,
			Текст_ОшибкаВКонтрагенте(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(Данные.Контрагент.Идентификатор) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'У получателя уведомления %1 не указан идентификатор МЭДО'"),
			Данные.Контрагент.Наименование);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Данные.Документ,
			Текст_ОшибкаВКонтрагенте(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(Данные.Контрагент.АдресМЭДО) Тогда
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'У получателя уведомления %1 не указан адрес МЭДО'"),
			Данные.Контрагент.Наименование);
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, Данные.Документ,
			Текст_ОшибкаВКонтрагенте(), ТекстОшибкиПодробно, ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	НачатьТранзакцию();
	Попытка
		
		ПодкаталогСообщения = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(
			ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(Настройки.КаталогОтправки)
			+ Данные.ИдентификаторВходящегоСообщения);
		СоздатьКаталог(ПодкаталогСообщения);
		Данные.ПодкаталогСообщения = ПодкаталогСообщения;
		
		ПолноеИмяФайлаКонверта = ПодкаталогСообщения + "envelope.ini";
		
		Адресаты = Новый Массив();
		НомерАдресата = 0;
		
		Адресат = СтрШаблон("%1=%2", Формат(НомерАдресата, "ЧН=0; ЧГ=0"), Данные.Контрагент.АдресМЭДО);
		Адресаты.Добавить(Адресат);
		НомерАдресата = НомерАдресата + 1;
		АдресатыСтрокой = СтрСоединить(Адресаты, Символы.ПС);
		
		Конверт = Новый ТекстовыйДокумент();
		Конверт.УстановитьТекст(СтрШаблон(
			"[ПИСЬМО КП ПС СЗИ]
			|АВТООТПРАВКА=1
			|[АДРЕСАТЫ]
			|%1
			|[ФАЙЛЫ]
			|0=notification.xml",
			АдресатыСтрокой));
		Конверт.Записать(ПолноеИмяФайлаКонверта, "windows-1251");
		
		ПолноеИмяФайлаСообщения = ПодкаталогСообщения + "notification.xml";
		Пакет = ПакетXDTOСообщенияПоВерсииМЭДО(ВерсияМЭДО);
		ТипCommunication = Пакет.КорневыеСвойства.Получить("communication").Тип;
		communication = ФабрикаXDTO.Создать(ТипCommunication);
		
		communication.version = "" + ВерсияМЭДО;
		
		communication.header = ФабрикаXDTO.Создать(ТипCommunication.Свойства.Получить("header").Тип);
		communication.header.type = "Уведомление";
		communication.header.uid = НРег(Данные.ИдентификаторВходящегоСообщения);
		communication.header.created = 
			?(ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271, ДатаФорматаDateTimeZone(Данные.Дата), Данные.Дата);
		communication.header.source = НовыйОбъектСообщения("communicationPartner", ВерсияМЭДО);
		communication.header.source.uid = НРег(Данные.Организация.Идентификатор);
		communication.header.source.organization = Данные.Организация.Наименование;
		
		notification = НовыйОбъектСообщения("messageNotification", ВерсияМЭДО);
		ТипNotification = notification.Тип();
		notification.type = Данные.ТипУведомления;
		notification.uid = Нрег(Данные.ИдентификаторДокумента);
		notification.mid = НРег(Данные.ИдентификаторВходящегоСообщения);
		
		ПрисвоитьЗаполненное(notification.comment, Данные.Комментарий);
		
		
		// Раздел foundation - для всех видов уведомлений. Данные о документе, на который отвечает это уведомление:
		foundation = Неопределено;
		ЗаполнитьDocumentReference(foundation, Данные.СведенияОДокументе, ВерсияМЭДО);
		
		Если Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОПостановкеНаКонтроль Тогда
			
			ИсходящееУведомление_ЗаполнитьDocumentSent(notification, Данные, foundation);
			
		ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОРегистрации Тогда
			
			notification.documentAccepted
				= ФабрикаXDTO.Создать(ТипNotification.Свойства.Получить("documentAccepted").Тип);
			notification.documentAccepted.time = ТекущаяДатаСеанса();
			notification.documentAccepted.foundation = foundation;
			
			notification.documentAccepted.num = НовыйОбъектСообщения("documentNumber", ВерсияМЭДО);
			notification.documentAccepted.num.number = Данные.Регистрация.РегистрационныйНомер;
			notification.documentAccepted.num.date = Данные.Регистрация.ДатаРегистрации;
			
		ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОбОтказеВРегистрации Тогда
			
			notification.documentRefused = ФабрикаXDTO.Создать(ТипNotification.Свойства.Получить("documentRefused").Тип);
			notification.documentRefused.time = ТекущаяДатаСеанса();
			notification.documentRefused.foundation = foundation;
			
			Если ТипЗнч(notification.documentRefused.reason) = Тип("СписокXDTO") Тогда
				notification.documentRefused.reason.Добавить( Строка(Данные.ОтказВРегистрации.ПричинаОтказа) );
			Иначе
				// Для 2.7 значения перечисления в точности соответствуют перечислению reasonForRejection в XDTO-пакете
				notification.documentRefused.reason = Строка(Данные.ОтказВРегистрации.ПричинаОтказа);
			КонецЕсли;
			
		ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОПринятииКИсполнению Тогда
			
			ИсходящееУведомление_ЗаполнитьExecutorAssigned(notification, Данные, foundation);
			
		ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОПодготовкеДоклада Тогда
			
			ИсходящееУведомление_ЗаполнитьReportPrepared(notification, Данные, foundation);
			
		ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОНаправленииДоклада Тогда
			
			ИсходящееУведомление_ЗаполнитьReportSent(notification, Данные, foundation);
			
		ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОХодеИсполнения Тогда
			
			ИсходящееУведомление_ЗаполнитьCourseChanged(notification, Данные, foundation);
			
		ИначеЕсли Данные.ТипУведомленияСсылка = Перечисления.ТипыУведомленийМЭДО.ОбОпубликовании Тогда
			
			ИсходящееУведомление_ЗаполнитьDocumentPublished(notification, Данные, foundation);
			
		Иначе 
			ТекстОшибкиПодробно = СтрШаблон(
				НСтр("ru = 'При записи исходящего уведомления получен не предусмотренный тип уведомления - ""%1"".'"),
				Данные.ТипУведомленияСсылка);
			ЗаписьВЖурналСобытий(
				Перечисления.УровниСобытийМЭДО.Ошибка,
				Данные.УведомлениеСсылка,
				Текст_ОшибкаВУведомлении(),
				ТекстОшибкиПодробно,
				ДанныеОтвета);
			Возврат;
			
		КонецЕсли;
		
		communication.notification = notification;
		
		
		destination = НовыйОбъектСообщения("communicationPartner", ВерсияМЭДО);
		destination.uid = НРег(Данные.Контрагент.Идентификатор);
		destination.organization = Данные.Контрагент.Наименование;
		deliveryDestination = НовыйОбъектСообщения("deliveryDestination", ВерсияМЭДО);
		deliveryDestination.destination = destination;
		communication.deliveryIndex = ФабрикаXDTO.Создать(ТипCommunication.Свойства.Получить("deliveryIndex").Тип);
		communication.deliveryIndex.destination.Добавить(deliveryDestination);
		
		ЗаписьXML = Новый ЗаписьXML();
		ЗаписьXML.ОткрытьФайл(ПолноеИмяФайлаСообщения, "UTF-8");
		ЗаписьXML.ЗаписатьОбъявлениеXML();
		ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, communication, "communication",,, НазначениеТипаXML.Неявное);
		ЗаписьXML.Закрыть();
		
		
		// Заполним данные уведомления, меняющиеся при отправке.
		// Уведомление уже должно быть создано на этом этапе.
		Уведомление = Данные.УведомлениеСсылка.ПолучитьОбъект();
		Если Уведомление.ИдентификаторУведомления <> Данные.ИдентификаторВходящегоСообщения Тогда
			// Подстраховка, в нормальном режиме должно уже быть таким.
			Уведомление.ИдентификаторУведомления = Данные.ИдентификаторВходящегоСообщения;
		КонецЕсли;
		ДвоичныеДанныеКонверта = Новый ДвоичныеДанные(ПолноеИмяФайлаКонверта);
		Уведомление.ВерсияМЭДО = ВерсияМЭДО;
		Уведомление.ДанныеКонверта = Новый ХранилищеЗначения(ДвоичныеДанныеКонверта);
		ДвоичныеДанныеСообщения = Новый ДвоичныеДанные(ПолноеИмяФайлаСообщения);
		Уведомление.ДанныеСообщения = Новый ХранилищеЗначения(ДвоичныеДанныеСообщения, Новый СжатиеДанных(5));
		Уведомление.ГотовоКОтправке = Ложь;
		Уведомление.Отправлено = Истина;
		Уведомление.Записать();
		
		
		ЗафиксироватьТранзакцию();
		
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Информация,
			Данные.УведомлениеСсылка,
			Текст_ОбъектОтправленУспешно(),
			Текст_ОбъектОтправленУспешно(),
			ДанныеОтвета);
		
	Исключение
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			Данные.Документ,
			НСтр("ru = 'Ошибка создания исходящего уведомления'"),
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()),
			ДанныеОтвета);
		ОтменитьТранзакцию();
	КонецПопытки;
	
КонецПроцедуры

// Исходящее уведомление - заполнить структуру по части постановки на контроль из документа "Уведомление МЭДО".
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  УведомлениеСсылка - ДокументСсылка.УведомлениеМЭДО - источник, откуда заполнять.
//  КонтрольныеПунктыДокумента - ТаблицаЗначений - выгрузка из соответственной ТЧ уведомления.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ИсходящееУведомление_ЗаполнитьПостановкуНаКонтроль(
	Данные, УведомлениеСсылка, КонтрольныеПунктыДокумента, ДанныеОтвета)
	
	Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
		УведомлениеСсылка, 
		"ТипУведомления, ПостановкаНаКонтроль, Дата");
	
	Если Реквизиты.ПостановкаНаКонтроль = Неопределено Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВУведомлении(),
			ТекстПодробно_ОшибкаВУведомленииПоТипу(Реквизиты.ТипУведомления),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	
	Для Каждого СтрокаТЧ Из Реквизиты.ПостановкаНаКонтроль.Выгрузить() Цикл
		ЗаполнитьЗначенияСвойств(
			Данные.ПостановкаНаКонтроль, СтрокаТЧ,
			"ТребуетсяРегистрация, ТребуетсяИсполнение, ТребуетсяПубликация");
	КонецЦикла;
	
	Если КонтрольныеПунктыДокумента <> Неопределено Тогда
		Для Каждого СтрокаТЧ Из КонтрольныеПунктыДокумента Цикл
			Пункт = МЭДОСтруктурыДанных.НовыйПунктДокумента();
			ЗаполнитьЗначенияСвойств(
				Пункт, СтрокаТЧ,
				"НомерПоПорядку, ИдентификаторПункта, Наименование, ТекстПункта, СрокИсполнения, Комментарий");
			ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
				Пункт.Ответственный, СтрокаТЧ.Юрлицо, СтрокаТЧ.Ответственный, Реквизиты.Дата, ДанныеОтвета);
			Пункт.ПолноеПредставление = СтрокаТЧ.ОтветственныйПредставление;
			
			Данные.ПостановкаНаКонтроль.ПунктыДокумента.Добавить(Пункт);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Исходящее уведомление - заполнить структуру по части отказа в регистрации из документа "Уведомление МЭДО".
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  УведомлениеСсылка - ДокументСсылка.УведомлениеМЭДО - источник, откуда заполнять.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ИсходящееУведомление_ЗаполнитьОтказВРегистрации(Данные, УведомлениеСсылка, ДанныеОтвета)
	
	Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
		УведомлениеСсылка, "ТипУведомления, ОтказВРегистрации, Дата");
	Если Реквизиты.ОтказВРегистрации = Неопределено Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВУведомлении(),
			ТекстПодробно_ОшибкаВУведомленииПоТипу(Реквизиты.ТипУведомления),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Для Каждого СтрокаТЧ Из Реквизиты.ОтказВРегистрации.Выгрузить() Цикл
		Данные.ОтказВРегистрации.ПричинаОтказа = "" + СтрокаТЧ.ПричинаОтказа;
		Данные.ОтказВРегистрации.ПричинаОтказаСсылка = СтрокаТЧ.ПричинаОтказа;
	КонецЦикла;
	
КонецПроцедуры

// Исходящее уведомление - заполнить структуру по части принятия к исполнению из документа "Уведомление МЭДО".
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  УведомлениеСсылка - ДокументСсылка.УведомлениеМЭДО - источник, откуда заполнять.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ИсходящееУведомление_ЗаполнитьПринятиеКИсполнению(Данные, УведомлениеСсылка, ДанныеОтвета)
	
	Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
		УведомлениеСсылка, "ТипУведомления, ПринятиеКИсполнению, Дата");
	Если Реквизиты.ПринятиеКИсполнению = Неопределено Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВУведомлении(),
			ТекстПодробно_ОшибкаВУведомленииПоТипу(Реквизиты.ТипУведомления),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	
	Для Каждого СтрокаТЧ Из Реквизиты.ПринятиеКИсполнению.Выгрузить() Цикл
		
		ПрисвоитьЗаполненное(Данные.ПринятиеКИсполнению.ЮрлицоСсылка, СтрокаТЧ.Юрлицо);
		
		// Есть руководитель/секретарь:
		Если ЗначениеЗаполнено(СтрокаТЧ.РуководительСекретарь)
			Или ЗначениеЗаполнено(СтрокаТЧ.РуководительСекретарьПредставление) 
			Или ЗначениеЗаполнено(СтрокаТЧ.КомментарийРуководителяСекретаря) Тогда
			
			ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
				Данные.ПринятиеКИсполнению.РуководительСекретарь,
				СтрокаТЧ.Юрлицо,
				СтрокаТЧ.РуководительСекретарь,
				Реквизиты.Дата,
				ДанныеОтвета);
			
			ПрисвоитьЗаполненное(
				Данные.ПринятиеКИсполнению.РуководительСекретарь.ПолноеПредставление,
				СтрокаТЧ.РуководительСекретарьПредставление);
			Данные.ПринятиеКИсполнению.КомментарийРуководителяСекретаря = СтрокаТЧ.КомментарийРуководителяСекретаря;
		КонецЕсли;
		
		// Есть руководитель подразделеления:
		Если ЗначениеЗаполнено(СтрокаТЧ.РуководительПодразделения)
			Или ЗначениеЗаполнено(СтрокаТЧ.РуководительПодразделенияПредставление) 
			Или ЗначениеЗаполнено(СтрокаТЧ.КомментарийРуководителяПодразделения) Тогда
			
			ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
				Данные.ПринятиеКИсполнению.РуководительПодразделения,
				СтрокаТЧ.Юрлицо,
				СтрокаТЧ.РуководительПодразделения,
				Реквизиты.Дата,
				ДанныеОтвета);
			
			ПрисвоитьЗаполненное(
				Данные.ПринятиеКИсполнению.РуководительПодразделения.ПолноеПредставление, 
				СтрокаТЧ.РуководительПодразделенияПредставление);
			Данные.ПринятиеКИсполнению.КомментарийРуководителяПодразделения
				= СтрокаТЧ.КомментарийРуководителяПодразделения;
		КонецЕсли;
		
		// Есть исполнитель:
		Если ЗначениеЗаполнено(СтрокаТЧ.Исполнитель)
			Или ЗначениеЗаполнено(СтрокаТЧ.ИсполнительПредставление) 
			Или ЗначениеЗаполнено(СтрокаТЧ.КомментарийИсполнителя) Тогда
			
			ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
				Данные.ПринятиеКИсполнению.Исполнитель,
				СтрокаТЧ.Юрлицо,
				СтрокаТЧ.Исполнитель,
				Реквизиты.Дата,
				ДанныеОтвета);
			ПрисвоитьЗаполненное(
				Данные.ПринятиеКИсполнению.Исполнитель.ПолноеПредставление, СтрокаТЧ.ИсполнительПредставление);
			
			Данные.ПринятиеКИсполнению.КомментарийИсполнителя = СтрокаТЧ.КомментарийИсполнителя;
		КонецЕсли;
		
	КонецЦикла;

КонецПроцедуры

// Исходящее уведомление - заполнить структуру по части подготовки доклада из документа "Уведомление МЭДО".
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  УведомлениеСсылка - ДокументСсылка.УведомлениеМЭДО - источник, откуда заполнять.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ИсходящееУведомление_ЗаполнитьПодготовкуДоклада(Данные, УведомлениеСсылка, ДанныеОтвета)
	
	Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
		УведомлениеСсылка, "ТипУведомления, ПодготовкаДоклада, Дата");
	Если Реквизиты.ПодготовкаДоклада = Неопределено Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВУведомлении(),
			ТекстПодробно_ОшибкаВУведомленииПоТипу(Реквизиты.ТипУведомления),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Для Каждого СтрокаТЧ Из Реквизиты.ПодготовкаДоклада.Выгрузить() Цикл
		
		ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
			Данные.ПодготовкаДоклада.Ответственный,
			СтрокаТЧ.Юрлицо,
			СтрокаТЧ.Ответственный,
			Реквизиты.Дата,
			ДанныеОтвета);
		ПрисвоитьЗаполненное(
			Данные.ПодготовкаДоклада.Ответственный.ПолноеПредставление, СтрокаТЧ.ОтветственныйПредставление);
		
		Данные.ПодготовкаДоклада.ДатаПодписания = СтрокаТЧ.ДатаПодписания;
		Данные.ПодготовкаДоклада.КомментарийПодписания = СтрокаТЧ.КомментарийПодписания;
		
	КонецЦикла;
	
КонецПроцедуры

// Исходящее уведомление - заполнить структуру по части направления доклада из документа "Уведомление МЭДО".
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  УведомлениеСсылка - ДокументСсылка.УведомлениеМЭДО - источник, откуда заполнять.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ИсходящееУведомление_ЗаполнитьНаправлениеДоклада(Данные, УведомлениеСсылка, ДанныеОтвета)
	
	Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
		УведомлениеСсылка, "ТипУведомления, НаправлениеДоклада, Дата");
	Если Реквизиты.НаправлениеДоклада = Неопределено Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВУведомлении(),
			ТекстПодробно_ОшибкаВУведомленииПоТипу(Реквизиты.ТипУведомления),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Для Каждого СтрокаТЧ Из Реквизиты.НаправлениеДоклада.Выгрузить() Цикл
		
		ЗаполнитьСведенияОДокументе(
			Данные.НаправлениеДоклада.СведенияОДокументе,
			СтрокаТЧ.Юрлицо,
			СтрокаТЧ.Ответственный,
			Реквизиты.Дата,
			СтрокаТЧ.ДатаРегистрации,
			СтрокаТЧ.РегистрационныйНомер,
			СтрокаТЧ.Комментарий,
			ДанныеОтвета);
		
	КонецЦикла;
	
КонецПроцедуры

// Исходящее уведомление - заполнить структуру по части хода исполнения из документа "Уведомление МЭДО".
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  УведомлениеСсылка - ДокументСсылка.УведомлениеМЭДО - источник, откуда заполнять.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ИсходящееУведомление_ЗаполнитьХодИсполнения(Данные, УведомлениеСсылка, ДанныеОтвета);

	Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(УведомлениеСсылка, "ТипУведомления, ХодИсполнения, Дата");
	Если Реквизиты.ХодИсполнения = Неопределено Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВУведомлении(),
			ТекстПодробно_ОшибкаВУведомленииПоТипу(Реквизиты.ТипУведомления),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Для Каждого СтрокаТЧ Из Реквизиты.ХодИсполнения.Выгрузить() Цикл
		
		ЗаполнитьСведенияОДокументе(
			Данные.ХодИсполнения.СведенияОДокументе,
			СтрокаТЧ.Юрлицо,
			СтрокаТЧ.Ответственный,
			Реквизиты.Дата,
			СтрокаТЧ.ДатаРегистрации,
			СтрокаТЧ.РегистрационныйНомер,
			СтрокаТЧ.Комментарий,
			ДанныеОтвета);
			
		Данные.ХодИсполнения.ОписаниеХодаИсполнения = СтрокаТЧ.ОписаниеХодаИсполнения;
		
	КонецЦикла;
	
КонецПроцедуры

// Исходящее уведомление - заполнить структуру по части опубликования из документа "Уведомление МЭДО".
// 
// Параметры:
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  УведомлениеСсылка - ДокументСсылка.УведомлениеМЭДО - источник, откуда заполнять.
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ИсходящееУведомление_ЗаполнитьОпубликование(Данные, УведомлениеСсылка, ДанныеОтвета);

	Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(УведомлениеСсылка, "ТипУведомления, Опубликование, Дата");
	Если Реквизиты.Опубликование = Неопределено Тогда
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка,
			УведомлениеСсылка,
			Текст_ОшибкаВУведомлении(),
			ТекстПодробно_ОшибкаВУведомленииПоТипу(Реквизиты.ТипУведомления),
			ДанныеОтвета);
		Возврат;
	КонецЕсли;
	
	Для Каждого СтрокаТЧ Из Реквизиты.Опубликование.Выгрузить() Цикл
		Данные.Опубликование.РегистрационныеДанные.ДатаРегистрации = СтрокаТЧ.ДатаРегистрации;
		Данные.Опубликование.РегистрационныеДанные.РегистрационныйНомер = СтрокаТЧ.РегистрационныйНомер;
		Данные.Опубликование.ПечатныйОрган = СтрокаТЧ.ПечатныйОрган;
	КонецЦикла;
	
КонецПроцедуры

// Исходящее уведомление заполнить блок файла documentSent - постановка на контроль.
// 
// Параметры:
//  notification - ОбъектXDTO
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  foundation - ОбъектXDTO - этот общий блок вставляется во все типы уведомлений.
Процедура ИсходящееУведомление_ЗаполнитьDocumentSent(notification, Данные, foundation);
	
	documentSent = ФабрикаXDTO.Создать(notification.Тип().Свойства.Получить("documentSent").Тип);
	documentSent.foundation = foundation;
	clause = Неопределено;
	Если ЗаполнитьDocumentClause(clause, Данные.ПунктДокумента, Данные.ВерсияМЭДО) Тогда
		documentSent.clause = clause;
	КонецЕсли;
	documentSent.time = ТекущаяДатаСеанса();
	
	documentSent.needRegistration = Данные.ПостановкаНаКонтроль.ТребуетсяРегистрация;
	documentSent.needExecution = Данные.ПостановкаНаКонтроль.ТребуетсяИсполнение;
	documentSent.needPublication = Данные.ПостановкаНаКонтроль.ТребуетсяПубликация;
	
	documentSent.clauses = ФабрикаXDTO.Создать(
		notification.Тип().Свойства.Получить("documentSent").Тип.Свойства.Получить("clauses").Тип);
	Для Каждого Пункт Из Данные.ПостановкаНаКонтроль.ПунктыДокумента Цикл
		clause = Неопределено;
		Если ЗаполнитьDocumentClause(clause, Пункт, Данные.ВерсияМЭДО) Тогда
			documentSent.clauses.clause.Добавить(clause);
		КонецЕсли;
	КонецЦикла;
	
	notification.documentSent = documentSent;
	
КонецПроцедуры

// Исходящее уведомление заполнить блок файла executorAssigned - принятие к исполнению.
// 
// Параметры:
//  notification - ОбъектXDTO
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  foundation - ОбъектXDTO - этот общий блок вставляется во все типы уведомлений.
Процедура ИсходящееУведомление_ЗаполнитьExecutorAssigned(notification, Данные, foundation)
	
	executorAssigned = ФабрикаXDTO.Создать(notification.Тип().Свойства.Получить("executorAssigned").Тип);
	executorAssigned.foundation = foundation;
	clause = Неопределено;
	Если ЗаполнитьDocumentClause(clause, Данные.ПунктДокумента, Данные.ВерсияМЭДО) Тогда
		executorAssigned.clause = clause;
	КонецЕсли;
	executorAssigned.time = ТекущаяДатаСеанса();
	
	secretary = ФабрикаXDTO.Создать(executorAssigned.Тип().Свойства.Получить("secretary").Тип);
	ЕстьДанные = Ложь;
	Если ЗаполнитьAnyone(secretary, Данные.ПринятиеКИсполнению.РуководительСекретарь, Данные.ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(secretary.comment, Данные.ПринятиеКИсполнению.КомментарийРуководителяСекретаря) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЕстьДанные Тогда
		executorAssigned.secretary = secretary;
	КонецЕсли;
	
	manager = ФабрикаXDTO.Создать(executorAssigned.Тип().Свойства.Получить("manager").Тип);
	ЕстьДанные = Ложь;
	Если ЗаполнитьAnyone(manager, Данные.ПринятиеКИсполнению.РуководительПодразделения, Данные.ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(manager.comment, Данные.ПринятиеКИсполнению.КомментарийРуководителяПодразделения) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЕстьДанные Тогда
		executorAssigned.manager = manager;
	КонецЕсли;
	
	
	executor = ФабрикаXDTO.Создать(executorAssigned.Тип().Свойства.Получить("executor").Тип);
	ЕстьДанные = Ложь;
	Если ЗаполнитьAnyone(executor, Данные.ПринятиеКИсполнению.Исполнитель, Данные.ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(executor.comment, Данные.ПринятиеКИсполнению.КомментарийИсполнителя) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЕстьДанные Тогда
		executorAssigned.executor = executor;
	КонецЕсли;
	
	notification.executorAssigned = executorAssigned;
	
КонецПроцедуры

// Исходящее уведомление заполнить блок файла reportPrepared - подготовка доклада.
// 
// Параметры:
//  notification - ОбъектXDTO
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  foundation - ОбъектXDTO - этот общий блок вставляется во все типы уведомлений.
Процедура ИсходящееУведомление_ЗаполнитьReportPrepared(notification, Данные, foundation)

	reportPrepared = ФабрикаXDTO.Создать(notification.Тип().Свойства.Получить("reportPrepared").Тип);
	reportPrepared.foundation = foundation;
	clause = Неопределено;
	Если ЗаполнитьDocumentClause(clause, Данные.ПунктДокумента, Данные.ВерсияМЭДО) Тогда
		reportPrepared.clause = clause;
	КонецЕсли;
	reportPrepared.time = ТекущаяДатаСеанса();
	
	signatory = НовыйОбъектСообщения("signatory", Данные.ВерсияМЭДО);
	ЕстьДанные = Ложь;
	Если ЗаполнитьAnyone(signatory, Данные.ПодготовкаДоклада.Ответственный, Данные.ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(signatory.signed, Данные.ПодготовкаДоклада.ДатаПодписания) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(signatory.comment, Данные.ПодготовкаДоклада.КомментарийПодписания) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЕстьДанные Тогда
		reportPrepared.signatory = signatory;
	КонецЕсли;
	
	notification.reportPrepared = reportPrepared;

КонецПроцедуры

// Исходящее уведомление заполнить блок файла reportSent - направление доклада.
// 
// Параметры:
//  notification - ОбъектXDTO
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  foundation - ОбъектXDTO - этот общий блок вставляется во все типы уведомлений.
Процедура ИсходящееУведомление_ЗаполнитьReportSent(notification, Данные, foundation)

	reportSent = ФабрикаXDTO.Создать(notification.Тип().Свойства.Получить("reportSent").Тип);
	reportSent.foundation = foundation;
	clause = Неопределено;
	Если ЗаполнитьDocumentClause(clause, Данные.ПунктДокумента, Данные.ВерсияМЭДО) Тогда
		reportSent.clause = clause;
	КонецЕсли;
	reportSent.time = ТекущаяДатаСеанса();
	
	report = Неопределено;
	ЗаполнитьDocumentReference(report, Данные.НаправлениеДоклада.СведенияОДокументе, Данные.ВерсияМЭДО);
	reportSent.report = report;

	notification.reportSent = reportSent;

КонецПроцедуры

// Исходящее уведомление заполнить блок файла courseChanged - ход исполнения.
// 
// Параметры:
//  notification - ОбъектXDTO
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  foundation - ОбъектXDTO - этот общий блок вставляется во все типы уведомлений.
Процедура ИсходящееУведомление_ЗаполнитьCourseChanged(notification, Данные, foundation)

	courseChanged = ФабрикаXDTO.Создать(notification.Тип().Свойства.Получить("courseChanged").Тип);
	courseChanged.foundation = foundation;
	clause = Неопределено;
	Если ЗаполнитьDocumentClause(clause, Данные.ПунктДокумента, Данные.ВерсияМЭДО) Тогда
		courseChanged.clause = clause;
	КонецЕсли;
	courseChanged.time = ТекущаяДатаСеанса();
	
	courseChanged.courseText = Данные.ХодИсполнения.ОписаниеХодаИсполнения;
	reference = Неопределено;
	ЗаполнитьDocumentReference(reference, Данные.ХодИсполнения.СведенияОДокументе, Данные.ВерсияМЭДО);
	courseChanged.reference = reference;
	
	notification.courseChanged = courseChanged;

КонецПроцедуры

// Исходящее уведомление заполнить блок файла documentPublished - опубликование.
// 
// Параметры:
//  notification - ОбъектXDTO
//  Данные - см. МЭДОСтруктурыДанных.НовыйДанныеИсходящегоУведомленияДляОтправки.
//  foundation - ОбъектXDTO - этот общий блок вставляется во все типы уведомлений.
Процедура ИсходящееУведомление_ЗаполнитьDocumentPublished(notification, Данные, foundation)

	documentPublished = ФабрикаXDTO.Создать(notification.Тип().Свойства.Получить("documentPublished").Тип);
	documentPublished.foundation = foundation;
	clause = Неопределено;
	Если ЗаполнитьDocumentClause(clause, Данные.ПунктДокумента, Данные.ВерсияМЭДО) Тогда
		documentPublished.clause = clause;
	КонецЕсли;
	documentPublished.time = ТекущаяДатаСеанса();
	
	num = ФабрикаXDTO.Создать(documentPublished.Тип().Свойства.Получить("num").Тип);
	num.number = Данные.Опубликование.РегистрационныеДанные.РегистрационныйНомер;
	num.date = Данные.Опубликование.РегистрационныеДанные.ДатаРегистрации;
	documentPublished.num = num;
	documentPublished.publicationPoint = Данные.Опубликование.ПечатныйОрган;
	
	notification.documentPublished = documentPublished;

КонецПроцедуры

// Заполнить объект documentReference.
// 
// Параметры:
//  documentReference - ОбъектXDTO, Неопределено - если Неопределено, то создается внутри. Объект, который нужно заполнить.
//  СведенияОДокументе - см. МЭДОСтруктурыДанных.НовыйСведенияОДокументе.
//  ВерсияМЭДО - ПеречислениеСсылка.ВерсииФорматаМЭДО
//
// Возвращаемое значение:
//  Булево - Истина, если удалось заполнить, Ложь, если на вход пришел объект без данных.
Функция ЗаполнитьDocumentReference(documentReference, СведенияОДокументе, ВерсияМЭДО);
	
	Если documentReference = Неопределено Тогда
		documentReference = НовыйОбъектСообщения("documentReference", ВерсияМЭДО);
	КонецЕсли;
	
	ЕстьДанные = Ложь;
	Если ЗаполнитьQualifiedValue(documentReference.organization, СведенияОДокументе.Юрлицо, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЗаполнитьQualifiedValue(documentReference.person, СведенияОДокументе.Персона, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЗаполнитьQualifiedValue(documentReference.department, СведенияОДокументе.Подразделение, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЗаполнитьQualifiedValue(documentReference.post, СведенияОДокументе.Должность, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЗаполнитьDocumentNumber(documentReference.num, СведенияОДокументе.РегистрационныеДанные, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(documentReference.comment, СведенияОДокументе.Комментарий) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	
	Если Не ЕстьДанные Тогда
		ЕстьДанные = ПрисвоитьЗаполненное(documentReference.comment, СведенияОДокументе.ПолноеПредставление);
	КонецЕсли;
	
	Возврат ЕстьДанные;
	
КонецФункции

// Заполнить объект qualifiedValue. 
// 
// Параметры:
//  qualifiedValue - ОбъектXDTO, Неопределено - если Неопределено, то создается внутри. Объект, который нужно заполнить.
//  ОграниченноеЗначение - см. МЭДОСтруктурыДанных.НовыйОграниченноеЗначение.
//  ВерсияМЭДО - ПеречислениеСсылка.ВерсииФорматаМЭДО
// 
// Возвращаемое значение:
//  Булево - Истина, если удалось заполнить, Ложь, если на вход пришел объект без данных.
Функция ЗаполнитьQualifiedValue(qualifiedValue, ОграниченноеЗначение, ВерсияМЭДО)
	
	Если Не ЗначениеЗаполнено(ОграниченноеЗначение.Наименование) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если qualifiedValue = Неопределено Тогда
		qualifiedValue = НовыйОбъектСообщения("qualifiedValue", ВерсияМЭДО);
	КонецЕсли;
	
	qualifiedValue.__content = ОграниченноеЗначение.Наименование;
	ПрисвоитьЗаполненное(qualifiedValue.id, ОграниченноеЗначение.Идентификатор);
	
	Возврат Истина;
	
КонецФункции

// Заполнить объект documentNumber. 
// 
// Параметры:
//  documentNumber - ОбъектXDTO, Неопределено - если Неопределено, то создается внутри. Объект, который нужно заполнить.
//  РегистрационныеДанные - см. МЭДОСтруктурыДанных.НовыйРегистрация.
//  ВерсияМЭДО - ПеречислениеСсылка.ВерсииФорматаМЭДО
// 
// Возвращаемое значение:
//  Булево - Истина, если удалось заполнить, Ложь, если на вход пришел объект без данных.
Функция ЗаполнитьDocumentNumber(documentNumber, РегистрационныеДанные, ВерсияМЭДО)
	
	Если Не ЗначениеЗаполнено(РегистрационныеДанные.РегистрационныйНомер)
		И Не ЗначениеЗаполнено(РегистрационныеДанные.ДатаРегистрации) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если documentNumber = Неопределено Тогда
		documentNumber = НовыйОбъектСообщения("documentNumber", ВерсияМЭДО);
	КонецЕсли;
	
	documentNumber.number = РегистрационныеДанные.РегистрационныйНомер;
	ПрисвоитьЗаполненное(documentNumber.date, РегистрационныеДанные.ДатаРегистрации);
	
	Возврат Истина;
	
КонецФункции

// Заполнить объект documentClause.
// 
// Параметры:
//  clause - ОбъектXDTO, Неопределено - если Неопределено, то создается внутри. Объект, который нужно заполнить.
//  Пункт - см. МЭДОСтруктурыДанных.НовыйПунктДокумента.
//  ВерсияМЭДО - ПеречислениеСсылка.ВерсииФорматаМЭДО
//
// Возвращаемое значение:
//  Булево - Истина, если удалось заполнить, Ложь, если на вход пришел объект без данных.
Функция ЗаполнитьDocumentClause(clause, Пункт, ВерсияМЭДО)
	
	Если clause = Неопределено Тогда
		clause = НовыйОбъектСообщения("documentClause", ВерсияМЭДО);
	КонецЕсли;
	
	ЕстьДанные = Ложь;
	Если ПрисвоитьЗаполненное(clause.localId, Пункт.НомерПоПорядку) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(clause.id, Пункт.ИдентификаторПункта) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(clause.designation, Пункт.Наименование) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(clause.text, Пункт.ТекстПункта) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(clause.deadline, Пункт.СрокИсполнения) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	
	ЕстьPrincipal = Ложь;
	principal = НовыйОбъектСообщения("addressee", ВерсияМЭДО);
	Если ЗаполнитьAnyone(principal, Пункт.Ответственный, ВерсияМЭДО) Тогда
		ЕстьPrincipal = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(principal.comment, Пункт.Комментарий) Тогда
		ЕстьPrincipal = Истина;
	КонецЕсли;
	
	Если ЕстьДанные И ЕстьPrincipal Тогда
		clause.principal = principal;
		Возврат Истина;
	КонецЕсли;
	
	Возврат ЕстьДанные;
	
КонецФункции

// Заполнить объект anyone. Объект типа anyone подается на вход и возвращается заполненный, это может быть
// как непосредственно anyone, так и объект с базовым типом anyone - (например addressee)
// 
// Параметры:
//  anyone - ОбъектXDTO, Неопределено - если Неопределено, то создается внутри. Объект, который нужно заполнить.
//  ОтветственнаяСтруктурнаяЕдиница - см. МЭДОСтруктурыДанных.НовыйОтветственнаяСтруктурнаяЕдиница.
//  ВерсияМЭДО - ПеречислениеСсылка.ВерсииФорматаМЭДО
//
// Возвращаемое значение:
//  Булево - Истина, если удалось заполнить, Ложь, если на вход пришел объект без данных.
Функция ЗаполнитьAnyone(anyone, ОтветственнаяСтруктурнаяЕдиница, ВерсияМЭДО)
	
	Если anyone = Неопределено Тогда
		anyone = НовыйОбъектСообщения("anyone", ВерсияМЭДО);
	КонецЕсли;
	
	ЕстьДанные = Ложь;
	Если ЗаполнитьQualifiedValue(anyone.region, ОтветственнаяСтруктурнаяЕдиница.Регион, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЗаполнитьQualifiedValue(anyone.organization, ОтветственнаяСтруктурнаяЕдиница.Юрлицо, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЗаполнитьQualifiedValue(anyone.person, ОтветственнаяСтруктурнаяЕдиница.Персона, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЗаполнитьQualifiedValue(anyone.department, ОтветственнаяСтруктурнаяЕдиница.Подразделение, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ЗаполнитьQualifiedValue(anyone.post, ОтветственнаяСтруктурнаяЕдиница.Должность, ВерсияМЭДО) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	Если ПрисвоитьЗаполненное(anyone.contactInfo, ОтветственнаяСтруктурнаяЕдиница.КонтактнаяИнформацияПредставление) Тогда
		ЕстьДанные = Истина;
	КонецЕсли;
	
	Возврат ЕстьДанные;
	
КонецФункции

#КонецОбласти

// Заполнить ответственную структурную единицу. Заполняет структуру, поданную на вход.
// 
// Параметры:
//  ОтветственнаяСтруктурнаяЕдиница - см. МЭДОСтруктурыДанных.НовыйОтветственнаяСтруктурнаяЕдиница.
//  ЮрлицоСсылка - ОпределяемыйТип.ЮрлицоМЭДО
//  КонтактноеЛицоСсылка - ОпределяемыйТип.КонтактноеЛицоМЭДО
//  ДатаСведений - Дата
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ЗаполнитьОтветственнуюСтруктурнуюЕдиницу(
	ОтветственнаяСтруктурнаяЕдиница,
	ЮрлицоСсылка,
	КонтактноеЛицоСсылка,
	ДатаСведений,
	ДанныеОтвета)
	
	Если ЭтоОрганизация(ЮрлицоСсылка) Тогда
		ПоляОрганизации = ПолучитьПоляОрганизации(ЮрлицоСсылка, ДатаСведений, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат;
		КонецЕсли;
		ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Наименование = ПоляОрганизации.Наименование;
		ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Идентификатор = ПоляОрганизации.Идентификатор;
	ИначеЕсли ЭтоКонтрагент(ЮрлицоСсылка) Тогда
		ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Наименование
			= ИнтеграцияСМЭДО.НаименованиеЮрлицаНаДату(ЮрлицоСсылка, ДатаСведений);
		ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Идентификатор = ИнтеграцияСМЭДО.ИдентификаторВнешнегоОбъекта(
			ЮрлицоСсылка, Обозначение_ВнешнийКонтрагент());
	КонецЕсли;
	
	ОтветственнаяСтруктурнаяЕдиница.ЮрлицоСсылка = ЮрлицоСсылка;
	
	Если ЗначениеЗаполнено(КонтактноеЛицоСсылка) Тогда
		ПоляКЛ = ИнтеграцияСМЭДО.ПолучитьПоляКонтактногоЛица(КонтактноеЛицоСсылка, ДатаСведений);
		ОтветственнаяСтруктурнаяЕдиница.Персона.Наименование = ПоляКЛ.ФИО;
		// Если идентификатор контактного лица не найден в связях с другими системами, то отправим свой:
		ОтветственнаяСтруктурнаяЕдиница.Персона.Идентификатор = ЗаполненноеЗначение(
			ПоляКЛ.Идентификатор, "" + КонтактноеЛицоСсылка.УникальныйИдентификатор());
		ЗаполнитьЗначенияСвойств(
			ОтветственнаяСтруктурнаяЕдиница.Подразделение, ПоляКЛ.Подразделение);
		ЗаполнитьЗначенияСвойств(
			ОтветственнаяСтруктурнаяЕдиница.Должность, ПоляКЛ.Должность);
		
		ОтветственнаяСтруктурнаяЕдиница.КонтактнаяИнформацияПредставление
			= ПоляКЛ.КонтактнаяИнформацияПредставление;
			
		ОтветственнаяСтруктурнаяЕдиница.КонтактноеЛицоСсылка = КонтактноеЛицоСсылка;
	КонецЕсли;
	
	ОтветственнаяСтруктурнаяЕдиница.ПолноеПредставление
		= ПолучитьПредставлениеОтветственнойСтруктурнойЕдиницы(ОтветственнаяСтруктурнаяЕдиница);
	
КонецПроцедуры

// Получить представление ответственной структурной единицы с предварительно заполненными остальными полями.
// 
// Параметры:
//  ОтветственнаяСтруктурнаяЕдиница - см. МЭДОСтруктурыДанных.НовыйОтветственнаяСтруктурнаяЕдиница.
// 
// Возвращаемое значение:
//  Строка
Функция ПолучитьПредставлениеОтветственнойСтруктурнойЕдиницы(ОтветственнаяСтруктурнаяЕдиница)
	
	Возврат ЗаполненноеЗначениеСтрокой(
		НСтр("ru = 'Регион:'"),
		ОтветственнаяСтруктурнаяЕдиница.Регион.Наименование,
		Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Организация/Учреждение:'"),
			ОтветственнаяСтруктурнаяЕдиница.Юрлицо.Наименование,
			Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'ФИО:'"),
			ОтветственнаяСтруктурнаяЕдиница.Персона.Наименование,
			Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Подразделение:'"),
			ОтветственнаяСтруктурнаяЕдиница.Подразделение.Наименование,
			Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Должность:'"),
			ОтветственнаяСтруктурнаяЕдиница.Должность.Наименование,
			Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Контактная информация:'"),
			ОтветственнаяСтруктурнаяЕдиница.КонтактнаяИнформацияПредставление,
			Символы.ПС, "");
	
КонецФункции

// Заполнить переданную структуру СведенияОДокументе.
// 
// Параметры:
//  СведенияОДокументе - см. МЭДОСтруктурыДанных.НовыйСведенияОДокументе.
//  ЮрлицоСсылка - ОпределяемыйТип.ЮрлицоМЭДО
//  КонтактноеЛицоСсылка - ОпределяемыйТип.КонтактноеЛицоМЭДО
//  ДатаСведений - Дата
//  ДатаРегистрации - Дата
//  РегистрационныйНомер - Строка
//  Комментарий - Строка
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
Процедура ЗаполнитьСведенияОДокументе(
	СведенияОДокументе,
	ЮрлицоСсылка,
	КонтактноеЛицоСсылка,
	ДатаСведений,
	ДатаРегистрации,
	РегистрационныйНомер,
	Комментарий,
	ДанныеОтвета)
	
	Если ЭтоОрганизация(ЮрлицоСсылка) Тогда
		ПоляОрганизации = ПолучитьПоляОрганизации(ЮрлицоСсылка, ДатаСведений, ДанныеОтвета);
		Если Не ДанныеОтвета.Успех Тогда
			Возврат;
		КонецЕсли;
		СведенияОДокументе.Юрлицо.Наименование = ПоляОрганизации.Наименование;
		СведенияОДокументе.Юрлицо.Идентификатор = ПоляОрганизации.Идентификатор;
	ИначеЕсли ЭтоКонтрагент(ЮрлицоСсылка) Тогда
		СведенияОДокументе.Юрлицо.Наименование = ИнтеграцияСМЭДО.НаименованиеЮрлицаНаДату(ЮрлицоСсылка, ДатаСведений);
		СведенияОДокументе.Юрлицо.Идентификатор = ИнтеграцияСМЭДО.ИдентификаторВнешнегоОбъекта(
			ЮрлицоСсылка, Обозначение_ВнешнийКонтрагент());
	КонецЕсли;
	
	СведенияОДокументе.ЮрлицоСсылка = ЮрлицоСсылка;
	
	Если ЗначениеЗаполнено(КонтактноеЛицоСсылка) Тогда
		ПоляКЛ = ИнтеграцияСМЭДО.ПолучитьПоляКонтактногоЛица(КонтактноеЛицоСсылка, ДатаСведений);
		СведенияОДокументе.Персона.Наименование = ПоляКЛ.ФИО;
		// Если идентификатор контактного лица не найден в связях с другими системами, то отправим свой:
		СведенияОДокументе.Персона.Идентификатор = ЗаполненноеЗначение(
			ПоляКЛ.Идентификатор, "" + КонтактноеЛицоСсылка.УникальныйИдентификатор());
		ЗаполнитьЗначенияСвойств(
			СведенияОДокументе.Подразделение, ПоляКЛ.Подразделение);
		ЗаполнитьЗначенияСвойств(
			СведенияОДокументе.Должность, ПоляКЛ.Должность);
		
		СведенияОДокументе.КонтактноеЛицоСсылка = КонтактноеЛицоСсылка;
	КонецЕсли;
	
	СведенияОДокументе.РегистрационныеДанные.ДатаРегистрации = ДатаРегистрации;
	СведенияОДокументе.РегистрационныеДанные.РегистрационныйНомер = РегистрационныйНомер;
	
	СведенияОДокументе.Комментарий = Комментарий;
	
	СведенияОДокументе.ПолноеПредставление = ПолучитьПредставлениеСведенийОДокументе(СведенияОДокументе);
	
КонецПроцедуры

Функция ПолучитьПредставлениеСведенийОДокументе(СведенияОДокументе)
	
	ТекстРегДанные = СтрШаблон(
		НСтр("ru = '%1 от %2'"),
		СведенияОДокументе.РегистрационныеДанные.РегистрационныйНомер,
		Формат(СведенияОДокументе.РегистрационныеДанные.ДатаРегистрации, "ДЛФ=D;"));
	
	Возврат ЗаполненноеЗначениеСтрокой(
		НСтр("ru = 'Регион:'"), СведенияОДокументе.Регион.Наименование, Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Организация/Учреждение:'"), СведенияОДокументе.Юрлицо.Наименование, Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'ФИО ответственного:'"), СведенияОДокументе.Персона.Наименование, Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Подразделение:'"), СведенияОДокументе.Подразделение.Наименование, Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Должность:'"), СведенияОДокументе.Должность.Наименование, Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Рег № доклада'"), ТекстРегДанные, Символы.ПС, "")
		+ ЗаполненноеЗначениеСтрокой(
			НСтр("ru = 'Комментарий:'"), СведенияОДокументе.Комментарий, Символы.ПС, "");
	
КонецФункции

Функция ЭтоОрганизация(ЮрлицоСсылка)
	
	Возврат ЗначениеЗаполнено(ЮрлицоСсылка)
		И Метаданные.ОпределяемыеТипы.Организация.Тип.СодержитТип(ТипЗнч(ЮрлицоСсылка));
	
КонецФункции

Функция ЭтоКонтрагент(ЮрлицоСсылка)
	
	Возврат ЗначениеЗаполнено(ЮрлицоСсылка)
		И Метаданные.ОпределяемыеТипы.КонтрагентМЭДО.Тип.СодержитТип(ТипЗнч(ЮрлицоСсылка));
	
КонецФункции

// Вспомогательная процедура - Создать запись об ошибке в регистре - журнале ошибок.
// Вызывается как напрямую, так и в виде фонового задания, чтобы произвести запись даже в случае отмены транзакции.
// Вызывается только из процедуры ЗаписьВЖурналСобытий.
//
// Параметры:
//  СтруктураЗаписи		- Структура
//  ДанныеОтвета		- Структура - см. НовыйОтвет или НовыйЛегкийОтвет.
// 
Процедура ЗаписьВЖурналСобытий_ВФонеИлиНепосредственно(СтруктураЗаписи, ДанныеОтвета) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запись = РегистрыСведений.ЖурналСобытийМЭДО.СоздатьМенеджерЗаписи();
	ЗаполнитьЗначенияСвойств(Запись, СтруктураЗаписи);
	
	Если ДанныеОтвета <> Неопределено
		И ДанныеОтвета.Свойство("Файл") И ЗначениеЗаполнено(ДанныеОтвета.Файл.ЛокальноеИмя) 
		И ТипЗнч(ДанныеОтвета.Файл.ДвоичныеДанные) = Тип("ДвоичныеДанные") Тогда
		Запись.АрхивЭСД	= Новый ХранилищеЗначения(ДанныеОтвета.Файл.ДвоичныеДанные);
		Запись.ИмяАрхиваЭСД = ДанныеОтвета.Файл.ЛокальноеИмя;
	КонецЕсли;
	
	Запись.Записать();
	
КонецПроцедуры

// Из всех символов имени файла оставляем только разрешенные - английские буквы, цифры
// В расширении файла допустимо только 3 или 4 символа, если не хватает - дополняем "_"
// 
// Параметры:
//  ИмяФайла - Строка - Имя файла
// 
// Возвращаемое значение:
//  Строка - Заменить неподходящие символы
Функция ЗаменитьНеподходящиеСимволы(Знач ИмяФайла)
	
	ИмяФайла = СтроковыеФункции.СтрокаЛатиницей(ИмяФайла);
	
	ИмяФайлаНовое = "";
	ДлинаСтроки = СтрДлина(ИмяФайла);
	
	Для Счетчик = 1 По ДлинаСтроки Цикл
		Символ = Сред(ИмяФайла, Счетчик, 1);
		КодСимвола = КодСимвола(Символ);
		
		Если КодСимвола >= КодСимвола("a") И КодСимвола <= КодСимвола("z") Тогда
			ИмяФайлаНовое = ИмяФайлаНовое + Символ;
		ИначеЕсли КодСимвола >= КодСимвола("A") И КодСимвола <= КодСимвола("Z") Тогда 
			ИмяФайлаНовое = ИмяФайлаНовое + Символ;
		ИначеЕсли КодСимвола >= КодСимвола("0") И КодСимвола <= КодСимвола("9" ) Тогда 
			ИмяФайлаНовое = ИмяФайлаНовое + Символ;
		ИначеЕсли ДлинаСтроки > 4 Тогда
			// любой другой символа - на "_", в короткой строке или расширении не ставим даже "_".
			ИмяФайлаНовое = ИмяФайлаНовое + "_";
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИмяФайлаНовое;
	
КонецФункции

#Область ЧтениеЗаписьСредствамиXDTO

Функция НовыйОбъектКонтейнера(Тип, ВерсияМЭДО)
	
	Возврат ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИменДляКонтейнера(ВерсияМЭДО), Тип));
	
КонецФункции

// Новый вложенный объект XDTO сообщения.
// 
// Параметры:
//  Тип - Строка - Тип
//  ВерсияМЭДО - ПеречислениеСсылка.ВерсииФорматаМЭДО - Версия МЭДО
// 
// Возвращаемое значение:
//  ЗначениеXDTO, ОбъектXDTO - Новый объект сообщения
Функция НовыйОбъектСообщения(Тип, ВерсияМЭДО)
	
	Возврат ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИменДляСообщения(ВерсияМЭДО), Тип));
	
КонецФункции

// Считывает версию МЭДО в XML-сообщении ЭСД, для понимания, какой пакет XDTO использовать.
// 
// Параметры:
//  ИмяФайла - Строка - Имя временного файла XML сообщения
//  ДанныеОтвета - см. МЭДОСтруктурыДанных.НовыйОтвет.
// 
// Возвращаемое значение:
//  Строка - Версия МЭДО.
Функция ПрочитатьВерсиюМЭДОИзЭСД(ИмяФайла, ДанныеОтвета)
	
	ВерсияМЭДО = "";
	ЧтениеXML = Новый ЧтениеXML();
	ЧтениеXML.ОткрытьФайл(ИмяФайла);
	Попытка
		Пока ЧтениеXML.Прочитать() Цикл
			Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента И СтрНайти(ЧтениеXML.Имя, "communication") > 0 Тогда
				Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
					Если СтрНайти(ЧтениеXML.Имя, "version") > 0 Тогда 
						ВерсияМЭДО = ЧтениеXML.Значение;
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			
			Прервать;
		КонецЦикла;
		ЧтениеXML.Закрыть();
	Исключение
		ЧтениеXML.Закрыть();
		
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, ИмяФайла, Текст_ОшибкаЧтенияXml(),
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), ДанныеОтвета);
	КонецПопытки;
	
	Возврат ВерсияМЭДО;
	
КонецФункции

Функция ПакетXDTOСообщенияПоВерсииМЭДО(ВерсияМЭДО)
	
	Возврат ФабрикаXDTO.Пакеты.Получить(ПространствоИменДляСообщения(ВерсияМЭДО));
	
КонецФункции

Функция ПакетXDTOКонтейнераПоВерсииМЭДО(ВерсияМЭДО)
	
	Возврат ФабрикаXDTO.Пакеты.Получить(ПространствоИменДляКонтейнера(ВерсияМЭДО));
	
КонецФункции

Функция ПространствоИменДляКонтейнера(ВерсияМЭДО)
	
	Если ВерсияМЭДО = "2.7.1" Или ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
		Возврат "urn:IEDMS:CONTAINER";
	КонецЕсли;
	
	Возврат "http://minsvyaz.ru/container";
	
КонецФункции

Функция ПространствоИменДляСообщения(ВерсияМЭДО)
	
	Если ВерсияМЭДО = "2.7.1" Или ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
		Возврат "urn:IEDMS:MESSAGE";
	КонецЕсли;
	
	Возврат "http://www.infpres.com/IEDMS";  // 2.5, 2.7
	
КонецФункции

// Версия паспорта может не совпадать с версией формата, есть исключения
Функция ВерсияПаспортаПоВерсииМЭДО(ВерсияМЭДО)
	
	Если ВерсияМЭДО = "2.7.1" Или ВерсияМЭДО = Перечисления.ВерсииФорматаМЭДО.Версия271 Тогда
		Возврат "2.7.1";
	КонецЕсли;
	
	Возврат "1.0";
	
КонецФункции

Функция ПрочитатьXMLФабрикой(ИмяФайла, ТипXDTO, ДанныеОтвета)

	ОбъектXDTOИзXML = Неопределено;

	ЧтениеXML = Новый ЧтениеXML();
	ЧтениеXML.ОткрытьФайл(ИмяФайла);
	Попытка
		ОбъектXDTOИзXML = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML, ТипXDTO);
		ЧтениеXML.Закрыть();
	Исключение
		ЧтениеXML.Закрыть();
		
		ЗаписьВЖурналСобытий(
			Перечисления.УровниСобытийМЭДО.Ошибка, ИмяФайла,
			Текст_ОшибкаЧтенияXml(), ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), ДанныеОтвета);
	КонецПопытки;
	
	Возврат ОбъектXDTOИзXML;
	
КонецФункции

Функция ЗначениеВМассивеXDTO(ПолеXDTO)
	Возврат ?(ТипЗнч(ПолеXDTO) = Тип("СписокXDTO"),
		ПолеXDTO,
		ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПолеXDTO));
КонецФункции

// Проверяет, есть ли свойство у объекта XDTO и оно заполнено.
// 
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - Объект XDTO
//  ИмяСвойства - Строка - Имя свойства
// 
// Возвращаемое значение:
//  Булево - Есть свойство объекта
Функция ЕстьСвойствоXDTO(ОбъектXDTO, ИмяСвойства)
	Возврат ОбъектXDTO.Свойства().Получить(ИмяСвойства) <> Неопределено И ОбъектXDTO[ИмяСвойства] <> Неопределено
КонецФункции

Функция СвойствоXDTOЕслиЕсть(ОбъектXDTO, ИмяСвойства, ЗначениеЕслиНет)
	Возврат ?(ЕстьСвойствоXDTO(ОбъектXDTO, ИмяСвойства), ОбъектXDTO[ИмяСвойства], ЗначениеЕслиНет);
КонецФункции

// Прочесть ограниченное значение. Если этого значения нет в сообщении xml, то возвращается пустая структура
// 
// Параметры:
//  ОбъектXDTOРодитель - ОбъектXDTO,Неопределено - Объект XDTO, свойство которого нужно прочесть
//  ИмяСвойства - Строка - Свойство должно иметь тип qualifiedValue, или по крайней мере иметь поля __content и id.
// 
// Возвращаемое значение:
//  Структура - см. МЭДОСтруктурыДанных.НовыйОграниченноеЗначение.
Функция ПрочитатьQualifiedValue(ОбъектXDTOРодитель, ИмяСвойства)
	
	Данные = МЭДОСтруктурыДанных.НовыйОграниченноеЗначение();
	ОбъектXDTO = СвойствоXDTOЕслиЕсть(ОбъектXDTOРодитель, ИмяСвойства, Неопределено);
	Если ОбъектXDTO <> Неопределено Тогда
		Данные.Идентификатор = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "id", "");
		Данные.Наименование = СвойствоXDTOЕслиЕсть(ОбъектXDTO, "__content", "");
	КонецЕсли;
	
	Возврат Данные;
КонецФункции

Функция ДатаФорматаDateTimeZone(Дата)
	
	Если Не ЗначениеЗаполнено(Дата) Тогда
		Возврат "";
	КонецЕсли;
		
	Возврат СтрШаблон(
		"%1+%2",
		Формат(Дата, "ДФ=гггг-ММ-дд'T'ЧЧ:мм:сс"),
		Формат((ТекущаяДатаСеанса() - ТекущаяУниверсальнаяДата()) / 3600, "ЧЦ=4; ЧДЦ=2; ЧРД=:; ЧВН=;") );
	
КонецФункции

// Возвращает дату из XML сообщения, которая в зависимости от версии может считываться средствами фабрики XDTO
// либо строкой либо непосредственно датой.
// 
// Параметры:
//  ДатаСтрокой - Строка,Дата - Дата строкой или датой, если сразу передана датой, то она и возвращается.
// 
// Возвращаемое значение:
//  Дата
Функция ЗначениеВДату(ДатаСтрокой)
	
	Если ТипЗнч(ДатаСтрокой) = Тип("Дата") Тогда
		Возврат ДатаСтрокой;// для 2.7 сразу дата.
	ИначеЕсли Не ЗначениеЗаполнено(ДатаСтрокой) Тогда
		Возврат '00010101';
	ИначеЕсли Найти(Лев(ДатаСтрокой, 4), "-") = 0 Тогда
		Возврат XMLЗначение(Тип("Дата"), ДатаСтрокой);
	Иначе
		Возврат Дата(Сред(ДатаСтрокой, 7, 4) + Сред(ДатаСтрокой, 4, 2) + Лев(ДатаСтрокой, 2));
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область ТекстовыеКонстанты

Функция Текст_ОбъектПолученУспешно()
	Возврат НСтр("ru = 'Объект получен успешно'");
КонецФункции

Функция Текст_ОбъектОтправленУспешно()
	Возврат НСтр("ru = 'Объект отправлен успешно'");
КонецФункции

Функция Текст_ВерсияНеПоддерживается(ВерсияМЭДО, ВременныйКаталог)
	Возврат СтрШаблон(
		НСтр("ru = 'Реализована только поддержка формата МЭДО 2.2, 2.5, 2.7, 2.7.1
		|Формат МЭДО %1 не поддерживается. Временный каталог %2'"), ВерсияМЭДО, ВременныйКаталог);
КонецФункции

Функция Текст_ОшибкаЧтенияXml()
	Возврат НСтр("ru = 'Ошибка чтения/разбора файла XML'");
КонецФункции

Функция Текст_ОшибкаВКонтрагенте()
	Возврат НСтр("ru = 'Ошибка в контрагенте'");
КонецФункции

Функция Текст_ОшибкаВРегистреСостояний()
	Возврат НСтр("ru = 'Ошибка в регистре состояний'");
КонецФункции

Функция Текст_ОшибкаЗагрузкиВходящегоУведомления()
	Возврат НСтр("ru = 'Ошибка загрузки входящего уведомления'");
КонецФункции

Функция Текст_ОшибкаЗаписиКвитанции()
	Возврат НСтр("ru = 'Ошибка записи квитанции'");
КонецФункции

Функция ТекстПодробно_ОшибкаВУведомленииПоТипу(ТипУведомления)
	Возврат СтрШаблон(НСтр("ru = 'В уведомлении типа %1 не заполнен соответствующий раздел'"), ТипУведомления);
КонецФункции

Функция Текст_ОшибкаВУведомлении()
	Возврат НСтр("ru = 'Ошибка в исходящем уведомлении'")
КонецФункции

Функция Текст_КаталогНеСуществует() Экспорт
	Возврат НСтр("ru = 'Каталог не существует или недоступен'");
КонецФункции

#КонецОбласти

#КонецОбласти

#КонецЕсли